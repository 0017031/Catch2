# # A test name that starts with a #
ok 1 - with 1 message: 'yay'
# #1005: Comparing pointer to int and long (NULL can be either on various systems)
ok 2 - fptr == 0 for: 0 == 0
# #1005: Comparing pointer to int and long (NULL can be either on various systems)
ok 3 - fptr == 0l for: 0 == 0
# #1027
ok 4 - y.v == 0 for: 0 == 0
# #1027
ok 5 - 0 == y.v for: 0 == 0
# #1027: Bitfields can be captured
ok 6 - y.v == 0 for: 0 == 0
# #1027: Bitfields can be captured
ok 7 - 0 == y.v for: 0 == 0
# #1147
ok 8 - t1 == t2 for: {?} == {?}
# #1147
ok 9 - t1 != t2 for: {?} != {?}
# #1147
ok 10 - t1 < t2 for: {?} < {?}
# #1147
ok 11 - t1 > t2 for: {?} > {?}
# #1147
ok 12 - t1 <= t2 for: {?} <= {?}
# #1147
ok 13 - t1 >= t2 for: {?} >= {?}
# #1175 - Hidden Test
ok 14 -
# #1238
ok 15 - std::memcmp(uarr, "123", sizeof(uarr)) == 0 for: 0 == 0 with 2 messages: 'uarr := "123"' and 'sarr := "456"'
# #1238
ok 16 - std::memcmp(sarr, "456", sizeof(sarr)) == 0 for: 0 == 0 with 2 messages: 'uarr := "123"' and 'sarr := "456"'
# #1245
ok 17 -
# #1319: Sections can have description (even if it is not saved
ok 18 -
# #1403
ok 19 - h1 == h2 for: [1403 helper] == [1403 helper]
# #1455 - INFO and WARN can start with a linebreak
warning 20 - '
This info message starts with a linebreak' with 1 message: '
This warning message starts with a linebreak'
This would not be caught previously
Nor would this
# #1514: stderr/stdout is not captured in tests aborted by an exception
not ok 21 - explicitly with 1 message: '1514'
# #1548
ok 22 - std::is_same<TypeList<int>, TypeList<int>>::value for: true
# #748 - captures with unexpected exceptions
not ok 23 - unexpected exception with message: 'answer := 42' with 1 message: 'expected exception'
# #748 - captures with unexpected exceptions
not ok 24 - unexpected exception with message: 'answer := 42'; expression was: thisThrows() with 1 message: 'expected exception'
# #748 - captures with unexpected exceptions
ok 25 - thisThrows() with 1 message: 'answer := 42'
# #809
ok 26 - 42 == f for: 42 == {?}
# #833
ok 27 - a == t for: 3 == 3
# #833
ok 28 - a == t for: 3 == 3
# #833
ok 29 - throws_int(true)
# #833
ok 30 - throws_int(true), int
# #833
ok 31 - throws_int(false)
# #833
ok 32 - "aaa", Catch::EndsWith("aaa") for: "aaa" ends with: "aaa"
# #833
ok 33 - templated_tests<int>(3) for: true
# #835 -- errno should not be touched by Catch
not ok 34 - f() == 0 for: 1 == 0
# #835 -- errno should not be touched by Catch
ok 35 - errno == 1 for: 1 == 1
# #872
ok 36 - x == 4 for: {?} == 4 with 1 message: 'dummy := 0'
# #961 -- Dynamically created sections should all be reported
ok 37 - with 1 message: 'Everything is OK'
# #961 -- Dynamically created sections should all be reported
ok 38 - with 1 message: 'Everything is OK'
# #961 -- Dynamically created sections should all be reported
ok 39 - with 1 message: 'Everything is OK'
# #961 -- Dynamically created sections should all be reported
ok 40 - with 1 message: 'Everything is OK'
# #961 -- Dynamically created sections should all be reported
ok 41 - with 1 message: 'Everything is OK'
# 'Not' checks that should fail
not ok 42 - false != false
# 'Not' checks that should fail
not ok 43 - true != true
# 'Not' checks that should fail
not ok 44 - !true for: false
# 'Not' checks that should fail
not ok 45 - !(true) for: !true
# 'Not' checks that should fail
not ok 46 - !trueValue for: false
# 'Not' checks that should fail
not ok 47 - !(trueValue) for: !true
# 'Not' checks that should fail
not ok 48 - !(1 == 1) for: false
# 'Not' checks that should fail
not ok 49 - !(1 == 1)
# 'Not' checks that should succeed
ok 50 - false == false
# 'Not' checks that should succeed
ok 51 - true == true
# 'Not' checks that should succeed
ok 52 - !false for: true
# 'Not' checks that should succeed
ok 53 - !(false) for: !false
# 'Not' checks that should succeed
ok 54 - !falseValue for: true
# 'Not' checks that should succeed
ok 55 - !(falseValue) for: !false
# 'Not' checks that should succeed
ok 56 - !(1 == 2) for: true
# 'Not' checks that should succeed
ok 57 - !(1 == 2)
# (unimplemented) static bools can be evaluated
ok 58 - is_true<true>::value == true for: true == true
# (unimplemented) static bools can be evaluated
ok 59 - true == is_true<true>::value for: true == true
# (unimplemented) static bools can be evaluated
ok 60 - is_true<false>::value == false for: false == false
# (unimplemented) static bools can be evaluated
ok 61 - false == is_true<false>::value for: false == false
# (unimplemented) static bools can be evaluated
ok 62 - !is_true<false>::value for: true
# (unimplemented) static bools can be evaluated
ok 63 - !!is_true<true>::value for: true
# (unimplemented) static bools can be evaluated
ok 64 - is_true<true>::value for: true
# (unimplemented) static bools can be evaluated
ok 65 - !(is_true<false>::value) for: !false
# 3x3x3 ints
ok 66 - x < y for: 1 < 4
# 3x3x3 ints
ok 67 - y < z for: 4 < 7
# 3x3x3 ints
ok 68 - x < z for: 1 < 7
# 3x3x3 ints
ok 69 - x < y for: 1 < 4
# 3x3x3 ints
ok 70 - y < z for: 4 < 8
# 3x3x3 ints
ok 71 - x < z for: 1 < 8
# 3x3x3 ints
ok 72 - x < y for: 1 < 4
# 3x3x3 ints
ok 73 - y < z for: 4 < 9
# 3x3x3 ints
ok 74 - x < z for: 1 < 9
# 3x3x3 ints
ok 75 - x < y for: 1 < 5
# 3x3x3 ints
ok 76 - y < z for: 5 < 7
# 3x3x3 ints
ok 77 - x < z for: 1 < 7
# 3x3x3 ints
ok 78 - x < y for: 1 < 5
# 3x3x3 ints
ok 79 - y < z for: 5 < 8
# 3x3x3 ints
ok 80 - x < z for: 1 < 8
# 3x3x3 ints
ok 81 - x < y for: 1 < 5
# 3x3x3 ints
ok 82 - y < z for: 5 < 9
# 3x3x3 ints
ok 83 - x < z for: 1 < 9
# 3x3x3 ints
ok 84 - x < y for: 1 < 6
# 3x3x3 ints
ok 85 - y < z for: 6 < 7
# 3x3x3 ints
ok 86 - x < z for: 1 < 7
# 3x3x3 ints
ok 87 - x < y for: 1 < 6
# 3x3x3 ints
ok 88 - y < z for: 6 < 8
# 3x3x3 ints
ok 89 - x < z for: 1 < 8
# 3x3x3 ints
ok 90 - x < y for: 1 < 6
# 3x3x3 ints
ok 91 - y < z for: 6 < 9
# 3x3x3 ints
ok 92 - x < z for: 1 < 9
# 3x3x3 ints
ok 93 - x < y for: 2 < 4
# 3x3x3 ints
ok 94 - y < z for: 4 < 7
# 3x3x3 ints
ok 95 - x < z for: 2 < 7
# 3x3x3 ints
ok 96 - x < y for: 2 < 4
# 3x3x3 ints
ok 97 - y < z for: 4 < 8
# 3x3x3 ints
ok 98 - x < z for: 2 < 8
# 3x3x3 ints
ok 99 - x < y for: 2 < 4
# 3x3x3 ints
ok 100 - y < z for: 4 < 9
# 3x3x3 ints
ok 101 - x < z for: 2 < 9
# 3x3x3 ints
ok 102 - x < y for: 2 < 5
# 3x3x3 ints
ok 103 - y < z for: 5 < 7
# 3x3x3 ints
ok 104 - x < z for: 2 < 7
# 3x3x3 ints
ok 105 - x < y for: 2 < 5
# 3x3x3 ints
ok 106 - y < z for: 5 < 8
# 3x3x3 ints
ok 107 - x < z for: 2 < 8
# 3x3x3 ints
ok 108 - x < y for: 2 < 5
# 3x3x3 ints
ok 109 - y < z for: 5 < 9
# 3x3x3 ints
ok 110 - x < z for: 2 < 9
# 3x3x3 ints
ok 111 - x < y for: 2 < 6
# 3x3x3 ints
ok 112 - y < z for: 6 < 7
# 3x3x3 ints
ok 113 - x < z for: 2 < 7
# 3x3x3 ints
ok 114 - x < y for: 2 < 6
# 3x3x3 ints
ok 115 - y < z for: 6 < 8
# 3x3x3 ints
ok 116 - x < z for: 2 < 8
# 3x3x3 ints
ok 117 - x < y for: 2 < 6
# 3x3x3 ints
ok 118 - y < z for: 6 < 9
# 3x3x3 ints
ok 119 - x < z for: 2 < 9
# 3x3x3 ints
ok 120 - x < y for: 3 < 4
# 3x3x3 ints
ok 121 - y < z for: 4 < 7
# 3x3x3 ints
ok 122 - x < z for: 3 < 7
# 3x3x3 ints
ok 123 - x < y for: 3 < 4
# 3x3x3 ints
ok 124 - y < z for: 4 < 8
# 3x3x3 ints
ok 125 - x < z for: 3 < 8
# 3x3x3 ints
ok 126 - x < y for: 3 < 4
# 3x3x3 ints
ok 127 - y < z for: 4 < 9
# 3x3x3 ints
ok 128 - x < z for: 3 < 9
# 3x3x3 ints
ok 129 - x < y for: 3 < 5
# 3x3x3 ints
ok 130 - y < z for: 5 < 7
# 3x3x3 ints
ok 131 - x < z for: 3 < 7
# 3x3x3 ints
ok 132 - x < y for: 3 < 5
# 3x3x3 ints
ok 133 - y < z for: 5 < 8
# 3x3x3 ints
ok 134 - x < z for: 3 < 8
# 3x3x3 ints
ok 135 - x < y for: 3 < 5
# 3x3x3 ints
ok 136 - y < z for: 5 < 9
# 3x3x3 ints
ok 137 - x < z for: 3 < 9
# 3x3x3 ints
ok 138 - x < y for: 3 < 6
# 3x3x3 ints
ok 139 - y < z for: 6 < 7
# 3x3x3 ints
ok 140 - x < z for: 3 < 7
# 3x3x3 ints
ok 141 - x < y for: 3 < 6
# 3x3x3 ints
ok 142 - y < z for: 6 < 8
# 3x3x3 ints
ok 143 - x < z for: 3 < 8
# 3x3x3 ints
ok 144 - x < y for: 3 < 6
# 3x3x3 ints
ok 145 - y < z for: 6 < 9
# 3x3x3 ints
ok 146 - x < z for: 3 < 9
# A METHOD_AS_TEST_CASE based test run that fails
not ok 147 - s == "world" for: "hello" == "world"
# A METHOD_AS_TEST_CASE based test run that succeeds
ok 148 - s == "hello" for: "hello" == "hello"
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails - Template_Foo<float>
not ok 149 - Template_Fixture_2<TestType>::m_a.size() == 1 for: 0 == 1
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails - Template_Foo<int>
not ok 150 - Template_Fixture_2<TestType>::m_a.size() == 1 for: 0 == 1
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails - std::vector<float>
not ok 151 - Template_Fixture_2<TestType>::m_a.size() == 1 for: 0 == 1
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails - std::vector<int>
not ok 152 - Template_Fixture_2<TestType>::m_a.size() == 1 for: 0 == 1
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds - Template_Foo<float>
ok 153 - Template_Fixture_2<TestType>::m_a.size() == 0 for: 0 == 0
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds - Template_Foo<int>
ok 154 - Template_Fixture_2<TestType>::m_a.size() == 0 for: 0 == 0
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds - std::vector<float>
ok 155 - Template_Fixture_2<TestType>::m_a.size() == 0 for: 0 == 0
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds - std::vector<int>
ok 156 - Template_Fixture_2<TestType>::m_a.size() == 0 for: 0 == 0
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - Template_Foo_2<float, 6>
not ok 157 - Template_Fixture_2<TestType>{}.m_a.size() < 2 for: 6 < 2
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - Template_Foo_2<int, 2>
not ok 158 - Template_Fixture_2<TestType>{}.m_a.size() < 2 for: 2 < 2
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array<float, 6>
not ok 159 - Template_Fixture_2<TestType>{}.m_a.size() < 2 for: 6 < 2
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails - std::array<int, 2>
not ok 160 - Template_Fixture_2<TestType>{}.m_a.size() < 2 for: 2 < 2
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - Template_Foo_2<float,6>
ok 161 - Template_Fixture_2<TestType>{}.m_a.size() >= 2 for: 6 >= 2
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - Template_Foo_2<int,2>
ok 162 - Template_Fixture_2<TestType>{}.m_a.size() >= 2 for: 2 >= 2
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - std::array<float,6>
ok 163 - Template_Fixture_2<TestType>{}.m_a.size() >= 2 for: 6 >= 2
# A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds - std::array<int,2>
ok 164 - Template_Fixture_2<TestType>{}.m_a.size() >= 2 for: 2 >= 2
# A TEMPLATE_TEST_CASE_METHOD based test run that fails - double
not ok 165 - Template_Fixture<TestType>::m_a == 2 for: 1.0 == 2
# A TEMPLATE_TEST_CASE_METHOD based test run that fails - float
not ok 166 - Template_Fixture<TestType>::m_a == 2 for: 1.0f == 2
# A TEMPLATE_TEST_CASE_METHOD based test run that fails - int
not ok 167 - Template_Fixture<TestType>::m_a == 2 for: 1 == 2
# A TEMPLATE_TEST_CASE_METHOD based test run that succeeds - double
ok 168 - Template_Fixture<TestType>::m_a == 1 for: 1.0 == 1
# A TEMPLATE_TEST_CASE_METHOD based test run that succeeds - float
ok 169 - Template_Fixture<TestType>::m_a == 1 for: 1.0f == 1
# A TEMPLATE_TEST_CASE_METHOD based test run that succeeds - int
ok 170 - Template_Fixture<TestType>::m_a == 1 for: 1 == 1
# A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 1
not ok 171 - Nttp_Fixture<V>::value == 0 for: 1 == 0
# A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 3
not ok 172 - Nttp_Fixture<V>::value == 0 for: 3 == 0
# A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails - 6
not ok 173 - Nttp_Fixture<V>::value == 0 for: 6 == 0
# A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 1
ok 174 - Nttp_Fixture<V>::value > 0 for: 1 > 0
# A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 3
ok 175 - Nttp_Fixture<V>::value > 0 for: 3 > 0
# A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds - 6
ok 176 - Nttp_Fixture<V>::value > 0 for: 6 > 0
# A TEST_CASE_METHOD based test run that fails
not ok 177 - m_a == 2 for: 1 == 2
# A TEST_CASE_METHOD based test run that succeeds
ok 178 - m_a == 1 for: 1 == 1
# A Template product test case - Foo<float>
ok 179 - x.size() == 0 for: 0 == 0
# A Template product test case - Foo<int>
ok 180 - x.size() == 0 for: 0 == 0
# A Template product test case - std::vector<float>
ok 181 - x.size() == 0 for: 0 == 0
# A Template product test case - std::vector<int>
ok 182 - x.size() == 0 for: 0 == 0
# A Template product test case with array signature - Bar<float, 42>
ok 183 - x.size() > 0 for: 42 > 0
# A Template product test case with array signature - Bar<int, 9>
ok 184 - x.size() > 0 for: 9 > 0
# A Template product test case with array signature - std::array<float, 42>
ok 185 - x.size() > 0 for: 42 > 0
# A Template product test case with array signature - std::array<int, 9>
ok 186 - x.size() > 0 for: 9 > 0
# A comparison that uses literals instead of the normal constructor
ok 187 - d == 1.23_a for: 1.23 == Approx( 1.23 )
# A comparison that uses literals instead of the normal constructor
ok 188 - d != 1.22_a for: 1.23 != Approx( 1.22 )
# A comparison that uses literals instead of the normal constructor
ok 189 - -d == -1.23_a for: -1.23 == Approx( -1.23 )
# A comparison that uses literals instead of the normal constructor
ok 190 - d == 1.2_a .epsilon(.1) for: 1.23 == Approx( 1.2 )
# A comparison that uses literals instead of the normal constructor
ok 191 - d != 1.2_a .epsilon(.001) for: 1.23 != Approx( 1.2 )
# A comparison that uses literals instead of the normal constructor
ok 192 - d == 1_a .epsilon(.3) for: 1.23 == Approx( 1.0 )
# A couple of nested sections followed by a failure
ok 193 - with 1 message: 'that's not flying - that's failing in style'
# A couple of nested sections followed by a failure
not ok 194 - explicitly with 1 message: 'to infinity and beyond'
# A failing expression with a non streamable type is still captured
not ok 195 - &o1 == &o2 for: 0x<hex digits> == 0x<hex digits>
# A failing expression with a non streamable type is still captured
not ok 196 - o1 == o2 for: {?} == {?}
# Absolute margin
ok 197 - 104.0 != Approx(100.0) for: 104.0 != Approx( 100.0 )
# Absolute margin
ok 198 - 104.0 == Approx(100.0).margin(5) for: 104.0 == Approx( 100.0 )
# Absolute margin
ok 199 - 104.0 == Approx(100.0).margin(4) for: 104.0 == Approx( 100.0 )
# Absolute margin
ok 200 - 104.0 != Approx(100.0).margin(3) for: 104.0 != Approx( 100.0 )
# Absolute margin
ok 201 - 100.3 != Approx(100.0) for: 100.3 != Approx( 100.0 )
# Absolute margin
ok 202 - 100.3 == Approx(100.0).margin(0.5) for: 100.3 == Approx( 100.0 )
# An expression with side-effects should only be evaluated once
ok 203 - i++ == 7 for: 7 == 7
# An expression with side-effects should only be evaluated once
ok 204 - i++ == 8 for: 8 == 8
# An unchecked exception reports the line of the last assertion
ok 205 - 1 == 1
# An unchecked exception reports the line of the last assertion
not ok 206 - unexpected exception with message: 'unexpected exception'; expression was: {Unknown expression after the reported line}
# Anonymous test case 1
ok 207 - with 1 message: 'anonymous test case'
# Approx setters validate their arguments
ok 208 - Approx(0).margin(0)
# Approx setters validate their arguments
ok 209 - Approx(0).margin(1234656)
# Approx setters validate their arguments
ok 210 - Approx(0).margin(-2), std::domain_error
# Approx setters validate their arguments
ok 211 - Approx(0).epsilon(0)
# Approx setters validate their arguments
ok 212 - Approx(0).epsilon(1)
# Approx setters validate their arguments
ok 213 - Approx(0).epsilon(-0.001), std::domain_error
# Approx setters validate their arguments
ok 214 - Approx(0).epsilon(1.0001), std::domain_error
# Approx with exactly-representable margin
ok 215 - 0.25f == Approx(0.0f).margin(0.25f) for: 0.25f == Approx( 0.0 )
# Approx with exactly-representable margin
ok 216 - 0.0f == Approx(0.25f).margin(0.25f) for: 0.0f == Approx( 0.25 )
# Approx with exactly-representable margin
ok 217 - 0.5f == Approx(0.25f).margin(0.25f) for: 0.5f == Approx( 0.25 )
# Approx with exactly-representable margin
ok 218 - 245.0f == Approx(245.25f).margin(0.25f) for: 245.0f == Approx( 245.25 )
# Approx with exactly-representable margin
ok 219 - 245.5f == Approx(245.25f).margin(0.25f) for: 245.5f == Approx( 245.25 )
# Approximate PI
ok 220 - divide( 22, 7 ) == Approx( 3.141 ).epsilon( 0.001 ) for: 3.1428571429 == Approx( 3.141 )
# Approximate PI
ok 221 - divide( 22, 7 ) != Approx( 3.141 ).epsilon( 0.0001 ) for: 3.1428571429 != Approx( 3.141 )
# Approximate comparisons with different epsilons
ok 222 - d != Approx( 1.231 ) for: 1.23 != Approx( 1.231 )
# Approximate comparisons with different epsilons
ok 223 - d == Approx( 1.231 ).epsilon( 0.1 ) for: 1.23 == Approx( 1.231 )
# Approximate comparisons with floats
ok 224 - 1.23f == Approx( 1.23f ) for: 1.23f == Approx( 1.2300000191 )
# Approximate comparisons with floats
ok 225 - 0.0f == Approx( 0.0f ) for: 0.0f == Approx( 0.0 )
# Approximate comparisons with ints
ok 226 - 1 == Approx( 1 ) for: 1 == Approx( 1.0 )
# Approximate comparisons with ints
ok 227 - 0 == Approx( 0 ) for: 0 == Approx( 0.0 )
# Approximate comparisons with mixed numeric types
ok 228 - 1.0f == Approx( 1 ) for: 1.0f == Approx( 1.0 )
# Approximate comparisons with mixed numeric types
ok 229 - 0 == Approx( dZero) for: 0 == Approx( 0.0 )
# Approximate comparisons with mixed numeric types
ok 230 - 0 == Approx( dSmall ).margin( 0.001 ) for: 0 == Approx( 0.00001 )
# Approximate comparisons with mixed numeric types
ok 231 - 1.234f == Approx( dMedium ) for: 1.234f == Approx( 1.234 )
# Approximate comparisons with mixed numeric types
ok 232 - dMedium == Approx( 1.234f ) for: 1.234 == Approx( 1.2339999676 )
# Arbitrary predicate matcher
ok 233 - 1, Predicate<int>(alwaysTrue, "always true") for: 1 matches predicate: "always true"
# Arbitrary predicate matcher
ok 234 - 1, !Predicate<int>(alwaysFalse, "always false") for: 1 not matches predicate: "always false"
# Arbitrary predicate matcher
ok 235 - "Hello olleH", Predicate<std::string>( [] (std::string const& str) -> bool { return str.front() == str.back(); }, "First and last character should be equal") for: "Hello olleH" matches predicate: "First and last character should be equal"
# Arbitrary predicate matcher
ok 236 - "This wouldn't pass", !Predicate<std::string>( [] (std::string const& str) -> bool { return str.front() == str.back(); } ) for: "This wouldn't pass" not matches undescribed predicate
# Assertions then sections
ok 237 - true
# Assertions then sections
ok 238 - true
# Assertions then sections
ok 239 - true
# Assertions then sections
ok 240 - true
# Assertions then sections
ok 241 - true
# Assertions then sections
ok 242 - true
# CAPTURE can deal with complex expressions
ok 243 - with 7 messages: 'a := 1' and 'b := 2' and 'c := 3' and 'a + b := 3' and 'a+b := 3' and 'c > b := true' and 'a == 1 := true'
# CAPTURE can deal with complex expressions involving commas
ok 244 - with 7 messages: 'std::vector<int>{1, 2, 3}[0, 1, 2] := 3' and 'std::vector<int>{1, 2, 3}[(0, 1)] := 2' and 'std::vector<int>{1, 2, 3}[0] := 1' and '(helper_1436<int, int>{12, -12}) := { 12, -12 }' and '(helper_1436<int, int>(-12, 12)) := { -12, 12 }' and '(1, 2) := 2' and '(2, 3) := 3'
# CAPTURE parses string and character constants
ok 245 - with 11 messages: '("comma, in string", "escaped, \", ") := "escaped, ", "' and '"single quote in string,'," := "single quote in string,',"' and '"some escapes, \\,\\\\" := "some escapes, \,\\"' and '"some, ), unmatched, } prenheses {[<" := "some, ), unmatched, } prenheses {[<"' and ''"' := '"'' and ''\'' := '''' and '',' := ','' and ''}' := '}'' and '')' := ')'' and ''(' := '('' and ''{' := '{''
# Capture and info messages
ok 246 - true with 1 message: 'i := 2'
# Capture and info messages
ok 247 - true with 1 message: '3'
# Character pretty printing
ok 248 - tab == '\t' for: '\t' == '\t'
# Character pretty printing
ok 249 - newline == '\n' for: '\n' == '\n'
# Character pretty printing
ok 250 - carr_return == '\r' for: '\r' == '\r'
# Character pretty printing
ok 251 - form_feed == '\f' for: '\f' == '\f'
# Character pretty printing
ok 252 - space == ' ' for: ' ' == ' '
# Character pretty printing
ok 253 - c == chars[i] for: 'a' == 'a'
# Character pretty printing
ok 254 - c == chars[i] for: 'z' == 'z'
# Character pretty printing
ok 255 - c == chars[i] for: 'A' == 'A'
# Character pretty printing
ok 256 - c == chars[i] for: 'Z' == 'Z'
# Character pretty printing
ok 257 - null_terminator == '\0' for: 0 == 0
# Character pretty printing
ok 258 - c == i for: 2 == 2
# Character pretty printing
ok 259 - c == i for: 3 == 3
# Character pretty printing
ok 260 - c == i for: 4 == 4
# Character pretty printing
ok 261 - c == i for: 5 == 5
# Commas in various macros are allowed
ok 262 - std::vector<constructor_throws>{constructor_throws{}, constructor_throws{}}
# Commas in various macros are allowed
ok 263 - std::vector<constructor_throws>{constructor_throws{}, constructor_throws{}}
# Commas in various macros are allowed
ok 264 - std::vector<int>{1, 2, 3} == std::vector<int>{1, 2, 3}
# Commas in various macros are allowed
ok 265 - std::vector<int>{1, 2, 3} == std::vector<int>{1, 2, 3}
# Commas in various macros are allowed
ok 266 - std::vector<int>{1, 2} == std::vector<int>{1, 2} for: { 1, 2 } == { 1, 2 }
# Commas in various macros are allowed
ok 267 - std::vector<int>{1, 2} == std::vector<int>{1, 2} for: { 1, 2 } == { 1, 2 }
# Commas in various macros are allowed
ok 268 - !(std::vector<int>{1, 2} == std::vector<int>{1, 2, 3}) for: !({ 1, 2 } == { 1, 2, 3 })
# Commas in various macros are allowed
ok 269 - !(std::vector<int>{1, 2} == std::vector<int>{1, 2, 3}) for: !({ 1, 2 } == { 1, 2, 3 })
# Commas in various macros are allowed
ok 270 - std::vector<int>{1, 2} == std::vector<int>{1, 2} for: { 1, 2 } == { 1, 2 }
# Commas in various macros are allowed
ok 271 - std::vector<int>{1, 2} == std::vector<int>{1, 2} for: { 1, 2 } == { 1, 2 }
# Commas in various macros are allowed
ok 272 - true
# Commas in various macros are allowed
ok 273 - std::vector<int>{1, 2} == std::vector<int>{1, 2} for: { 1, 2 } == { 1, 2 }
# Comparing function pointers
ok 274 - a for: 0x<hex digits>
# Comparing function pointers
ok 275 - a == &foo for: 0x<hex digits> == 0x<hex digits>
# Comparison ops
ok 276 - SimplePcg32{} == SimplePcg32{} for: {?} == {?}
# Comparison ops
ok 277 - SimplePcg32{ 0 } != SimplePcg32{} for: {?} != {?}
# Comparison ops
ok 278 - !(SimplePcg32{ 1 } == SimplePcg32{ 2 }) for: !({?} == {?})
# Comparison ops
ok 279 - !(SimplePcg32{ 1 } != SimplePcg32{ 1 }) for: !({?} != {?})
# Comparison with explicitly convertible types
ok 280 - td == Approx(10.0) for: StrongDoubleTypedef(10) == Approx( 10.0 )
# Comparison with explicitly convertible types
ok 281 - Approx(10.0) == td for: Approx( 10.0 ) == StrongDoubleTypedef(10)
# Comparison with explicitly convertible types
ok 282 - td != Approx(11.0) for: StrongDoubleTypedef(10) != Approx( 11.0 )
# Comparison with explicitly convertible types
ok 283 - Approx(11.0) != td for: Approx( 11.0 ) != StrongDoubleTypedef(10)
# Comparison with explicitly convertible types
ok 284 - td <= Approx(10.0) for: StrongDoubleTypedef(10) <= Approx( 10.0 )
# Comparison with explicitly convertible types
ok 285 - td <= Approx(11.0) for: StrongDoubleTypedef(10) <= Approx( 11.0 )
# Comparison with explicitly convertible types
ok 286 - Approx(10.0) <= td for: Approx( 10.0 ) <= StrongDoubleTypedef(10)
# Comparison with explicitly convertible types
ok 287 - Approx(9.0) <= td for: Approx( 9.0 ) <= StrongDoubleTypedef(10)
# Comparison with explicitly convertible types
ok 288 - td >= Approx(9.0) for: StrongDoubleTypedef(10) >= Approx( 9.0 )
# Comparison with explicitly convertible types
ok 289 - td >= Approx(td) for: StrongDoubleTypedef(10) >= Approx( 10.0 )
# Comparison with explicitly convertible types
ok 290 - Approx(td) >= td for: Approx( 10.0 ) >= StrongDoubleTypedef(10)
# Comparison with explicitly convertible types
ok 291 - Approx(11.0) >= td for: Approx( 11.0 ) >= StrongDoubleTypedef(10)
# Comparisons between ints where one side is computed
ok 292 - 54 == 6*9 for: 54 == 54
# Comparisons between unsigned ints and negative signed ints match c++ standard behaviour
ok 293 - ( -1 > 2u ) for: true
# Comparisons between unsigned ints and negative signed ints match c++ standard behaviour
ok 294 - -1 > 2u for: -1 > 2
# Comparisons between unsigned ints and negative signed ints match c++ standard behaviour
ok 295 - ( 2u < -1 ) for: true
# Comparisons between unsigned ints and negative signed ints match c++ standard behaviour
ok 296 - 2u < -1 for: 2 < -1
# Comparisons between unsigned ints and negative signed ints match c++ standard behaviour
ok 297 - ( minInt > 2u ) for: true
# Comparisons between unsigned ints and negative signed ints match c++ standard behaviour
ok 298 - minInt > 2u for: -2147483648 > 2
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 299 - i == 1 for: 1 == 1
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 300 - ui == 2 for: 2 == 2
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 301 - l == 3 for: 3 == 3
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 302 - ul == 4 for: 4 == 4
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 303 - c == 5 for: 5 == 5
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 304 - uc == 6 for: 6 == 6
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 305 - 1 == i for: 1 == 1
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 306 - 2 == ui for: 2 == 2
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 307 - 3 == l for: 3 == 3
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 308 - 4 == ul for: 4 == 4
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 309 - 5 == c for: 5 == 5
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 310 - 6 == uc for: 6 == 6
# Comparisons with int literals don't warn when mixing signed/ unsigned
ok 311 - (std::numeric_limits<uint32_t>::max)() > ul for: 4294967295 (0x<hex digits>) > 4
# Contains string matcher
not ok 312 - testStringForMatching(), Contains("not there", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" contains: "not there" (case insensitive)
# Contains string matcher
not ok 313 - testStringForMatching(), Contains("STRING") for: "this string contains 'abc' as a substring" contains: "STRING"
# Copy and then generate a range
ok 314 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 315 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 316 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 317 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 318 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 319 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 320 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 321 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 322 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 323 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 324 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 325 - elem % 2 == 1 for: 1 == 1
# Copy and then generate a range
ok 326 - call_count == 1 for: 1 == 1
# Copy and then generate a range
ok 327 - make_data().size() == test_count for: 6 == 6
# Custom exceptions can be translated when testing for nothrow
not ok 328 - unexpected exception with message: 'custom exception - not std'; expression was: throwCustom()
# Custom exceptions can be translated when testing for throwing as something else
not ok 329 - unexpected exception with message: 'custom exception - not std'; expression was: throwCustom(), std::exception
# Custom std-exceptions can be custom translated
not ok 330 - unexpected exception with message: 'custom std exception'
# Default scale is invisible to comparison
ok 331 - 101.000001 != Approx(100).epsilon(0.01) for: 101.000001 != Approx( 100.0 )
# Default scale is invisible to comparison
ok 332 - std::pow(10, -5) != Approx(std::pow(10, -7)) for: 0.00001 != Approx( 0.0000001 )
# Directly creating an EnumInfo
ok 333 - enumInfo->lookup(0) == "Value1" for: Value1 == "Value1"
# Directly creating an EnumInfo
ok 334 - enumInfo->lookup(1) == "Value2" for: Value2 == "Value2"
# Directly creating an EnumInfo
ok 335 - enumInfo->lookup(3) == "{** unexpected enum value **}" for: {** unexpected enum value **} == "{** unexpected enum value **}"
# EndsWith string matcher
not ok 336 - testStringForMatching(), EndsWith("Substring") for: "this string contains 'abc' as a substring" ends with: "Substring"
# EndsWith string matcher
not ok 337 - testStringForMatching(), EndsWith("this", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" ends with: "this" (case insensitive)
# Enums can quickly have stringification enabled using REGISTER_ENUM
ok 338 - stringify( EnumClass3::Value1 ) == "Value1" for: "Value1" == "Value1"
# Enums can quickly have stringification enabled using REGISTER_ENUM
ok 339 - stringify( EnumClass3::Value2 ) == "Value2" for: "Value2" == "Value2"
# Enums can quickly have stringification enabled using REGISTER_ENUM
ok 340 - stringify( EnumClass3::Value3 ) == "Value3" for: "Value3" == "Value3"
# Enums can quickly have stringification enabled using REGISTER_ENUM
ok 341 - stringify( EnumClass3::Value4 ) == "{** unexpected enum value **}" for: "{** unexpected enum value **}" == "{** unexpected enum value **}"
# Enums can quickly have stringification enabled using REGISTER_ENUM
ok 342 - stringify( ec3 ) == "Value2" for: "Value2" == "Value2"
# Enums in namespaces can quickly have stringification enabled using REGISTER_ENUM
ok 343 - stringify( Bikeshed::Colours::Red ) == "Red" for: "Red" == "Red"
# Enums in namespaces can quickly have stringification enabled using REGISTER_ENUM
ok 344 - stringify( Bikeshed::Colours::Blue ) == "Blue" for: "Blue" == "Blue"
# Epsilon only applies to Approx's value
ok 345 - 101.01 != Approx(100).epsilon(0.01) for: 101.01 != Approx( 100.0 )
# Equality checks that should fail
not ok 346 - data.int_seven == 6 for: 7 == 6
# Equality checks that should fail
not ok 347 - data.int_seven == 8 for: 7 == 8
# Equality checks that should fail
not ok 348 - data.int_seven == 0 for: 7 == 0
# Equality checks that should fail
not ok 349 - data.float_nine_point_one == Approx( 9.11f ) for: 9.1f == Approx( 9.1099996567 )
# Equality checks that should fail
not ok 350 - data.float_nine_point_one == Approx( 9.0f ) for: 9.1f == Approx( 9.0 )
# Equality checks that should fail
not ok 351 - data.float_nine_point_one == Approx( 1 ) for: 9.1f == Approx( 1.0 )
# Equality checks that should fail
not ok 352 - data.float_nine_point_one == Approx( 0 ) for: 9.1f == Approx( 0.0 )
# Equality checks that should fail
not ok 353 - data.double_pi == Approx( 3.1415 ) for: 3.1415926535 == Approx( 3.1415 )
# Equality checks that should fail
not ok 354 - data.str_hello == "goodbye" for: "hello" == "goodbye"
# Equality checks that should fail
not ok 355 - data.str_hello == "hell" for: "hello" == "hell"
# Equality checks that should fail
not ok 356 - data.str_hello == "hello1" for: "hello" == "hello1"
# Equality checks that should fail
not ok 357 - data.str_hello.size() == 6 for: 5 == 6
# Equality checks that should fail
not ok 358 - x == Approx( 1.301 ) for: 1.3 == Approx( 1.301 )
# Equality checks that should succeed
ok 359 - data.int_seven == 7 for: 7 == 7
# Equality checks that should succeed
ok 360 - data.float_nine_point_one == Approx( 9.1f ) for: 9.1f == Approx( 9.1000003815 )
# Equality checks that should succeed
ok 361 - data.double_pi == Approx( 3.1415926535 ) for: 3.1415926535 == Approx( 3.1415926535 )
# Equality checks that should succeed
ok 362 - data.str_hello == "hello" for: "hello" == "hello"
# Equality checks that should succeed
ok 363 - "hello" == data.str_hello for: "hello" == "hello"
# Equality checks that should succeed
ok 364 - data.str_hello.size() == 5 for: 5 == 5
# Equality checks that should succeed
ok 365 - x == Approx( 1.3 ) for: 1.3 == Approx( 1.3 )
# Equals
ok 366 - testStringForMatching(), Equals("this string contains 'abc' as a substring") for: "this string contains 'abc' as a substring" equals: "this string contains 'abc' as a substring"
# Equals
ok 367 - testStringForMatching(), Equals("this string contains 'ABC' as a substring", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" equals: "this string contains 'abc' as a substring" (case insensitive)
# Equals string matcher
not ok 368 - testStringForMatching(), Equals("this string contains 'ABC' as a substring") for: "this string contains 'abc' as a substring" equals: "this string contains 'ABC' as a substring"
# Equals string matcher
not ok 369 - testStringForMatching(), Equals("something else", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" equals: "something else" (case insensitive)
# Exception as a value (e.g. in REQUIRE_THROWS_MATCHES) can be stringified
ok 370 - ::Catch::Detail::stringify(WhatException{}) == "This exception has overridden what() method" for: "This exception has overridden what() method" == "This exception has overridden what() method"
# Exception as a value (e.g. in REQUIRE_THROWS_MATCHES) can be stringified
ok 371 - ::Catch::Detail::stringify(OperatorException{}) == "OperatorException" for: "OperatorException" == "OperatorException"
# Exception as a value (e.g. in REQUIRE_THROWS_MATCHES) can be stringified
ok 372 - ::Catch::Detail::stringify(StringMakerException{}) == "StringMakerException" for: "StringMakerException" == "StringMakerException"
# Exception matchers that fail
not ok 373 - expected exception, got none; expression was: doesNotThrow(), SpecialException, ExceptionMatcher{1}
# Exception matchers that fail
not ok 374 - expected exception, got none; expression was: doesNotThrow(), SpecialException, ExceptionMatcher{1}
# Exception matchers that fail
not ok 375 - unexpected exception with message: 'Unknown exception'; expression was: throwsAsInt(1), SpecialException, ExceptionMatcher{1}
# Exception matchers that fail
not ok 376 - unexpected exception with message: 'Unknown exception'; expression was: throwsAsInt(1), SpecialException, ExceptionMatcher{1}
# Exception matchers that fail
not ok 377 - throwsSpecialException(3), SpecialException, ExceptionMatcher{1} for: SpecialException::what special exception has value of 1
# Exception matchers that fail
not ok 378 - throwsSpecialException(4), SpecialException, ExceptionMatcher{1} for: SpecialException::what special exception has value of 1
# Exception matchers that succeed
ok 379 - throwsSpecialException(1), SpecialException, ExceptionMatcher{1} for: SpecialException::what special exception has value of 1
# Exception matchers that succeed
ok 380 - throwsSpecialException(2), SpecialException, ExceptionMatcher{2} for: SpecialException::what special exception has value of 2
# Exception messages can be tested for
ok 381 - thisThrows(), "expected exception" for: "expected exception" equals: "expected exception"
# Exception messages can be tested for
ok 382 - thisThrows(), Equals( "expecteD Exception", Catch::CaseSensitive::No ) for: "expected exception" equals: "expected exception" (case insensitive)
# Exception messages can be tested for
ok 383 - thisThrows(), StartsWith( "expected" ) for: "expected exception" starts with: "expected"
# Exception messages can be tested for
ok 384 - thisThrows(), EndsWith( "exception" ) for: "expected exception" ends with: "exception"
# Exception messages can be tested for
ok 385 - thisThrows(), Contains( "except" ) for: "expected exception" contains: "except"
# Exception messages can be tested for
ok 386 - thisThrows(), Contains( "exCept", Catch::CaseSensitive::No ) for: "expected exception" contains: "except" (case insensitive)
# Exceptions matchers
ok 387 - throwsDerivedException(), DerivedException, Message("DerivedException::what") for: DerivedException::what exception message matches "DerivedException::what"
# Exceptions matchers
ok 388 - throwsDerivedException(), DerivedException, !Message("derivedexception::what") for: DerivedException::what not exception message matches "derivedexception::what"
# Exceptions matchers
ok 389 - throwsSpecialException(2), SpecialException, !Message("DerivedException::what") for: SpecialException::what not exception message matches "DerivedException::what"
# Exceptions matchers
ok 390 - throwsSpecialException(2), SpecialException, Message("SpecialException::what") for: SpecialException::what exception message matches "SpecialException::what"
# Expected exceptions that don't throw or unexpected exceptions fail the test
not ok 391 - unexpected exception with message: 'expected exception'; expression was: thisThrows(), std::string
# Expected exceptions that don't throw or unexpected exceptions fail the test
not ok 392 - expected exception, got none; expression was: thisDoesntThrow(), std::domain_error
# Expected exceptions that don't throw or unexpected exceptions fail the test
not ok 393 - unexpected exception with message: 'expected exception'; expression was: thisThrows()
# FAIL aborts the test
not ok 394 - explicitly with 1 message: 'This is a failure'
# FAIL does not require an argument
not ok 395 - explicitly
# FAIL_CHECK does not abort the test
not ok 396 - explicitly with 1 message: 'This is a failure'
# FAIL_CHECK does not abort the test
warning 397 - 'This message appears in the output'
# Factorials are computed
ok 398 - Factorial(0) == 1 for: 1 == 1
# Factorials are computed
ok 399 - Factorial(1) == 1 for: 1 == 1
# Factorials are computed
ok 400 - Factorial(2) == 2 for: 2 == 2
# Factorials are computed
ok 401 - Factorial(3) == 6 for: 6 == 6
# Factorials are computed
ok 402 - Factorial(10) == 3628800 for: 3628800 (0x<hex digits>) == 3628800 (0x<hex digits>)
# Floating point matchers: double
ok 403 - 10., WithinRel(11.1, 0.1) for: 10.0 and 11.1 are within 10% of each other
# Floating point matchers: double
ok 404 - 10., !WithinRel(11.2, 0.1) for: 10.0 not and 11.2 are within 10% of each other
# Floating point matchers: double
ok 405 - 1., !WithinRel(0., 0.99) for: 1.0 not and 0 are within 99% of each other
# Floating point matchers: double
ok 406 - -0., WithinRel(0.) for: -0.0 and 0 are within 2.22045e-12% of each other
# Floating point matchers: double
ok 407 - v1, WithinRel(v2) for: 0.0 and 2.22507e-308 are within 2.22045e-12% of each other
# Floating point matchers: double
ok 408 - 1., WithinAbs(1., 0) for: 1.0 is within 0.0 of 1.0
# Floating point matchers: double
ok 409 - 0., WithinAbs(1., 1) for: 0.0 is within 1.0 of 1.0
# Floating point matchers: double
ok 410 - 0., !WithinAbs(1., 0.99) for: 0.0 not is within 0.99 of 1.0
# Floating point matchers: double
ok 411 - 0., !WithinAbs(1., 0.99) for: 0.0 not is within 0.99 of 1.0
# Floating point matchers: double
ok 412 - 11., !WithinAbs(10., 0.5) for: 11.0 not is within 0.5 of 10.0
# Floating point matchers: double
ok 413 - 10., !WithinAbs(11., 0.5) for: 10.0 not is within 0.5 of 11.0
# Floating point matchers: double
ok 414 - -10., WithinAbs(-10., 0.5) for: -10.0 is within 0.5 of -10.0
# Floating point matchers: double
ok 415 - -10., WithinAbs(-9.6, 0.5) for: -10.0 is within 0.5 of -9.6
# Floating point matchers: double
ok 416 - 1., WithinULP(1., 0) for: 1.0 is within 0 ULPs of 1.0000000000000000e+00 ([1.0000000000000000e+00, 1.0000000000000000e+00])
# Floating point matchers: double
ok 417 - nextafter(1., 2.), WithinULP(1., 1) for: 1.0 is within 1 ULPs of 1.0000000000000000e+00 ([9.9999999999999989e-01, 1.0000000000000002e+00])
# Floating point matchers: double
ok 418 - 0., WithinULP(nextafter(0., 1.), 1) for: 0.0 is within 1 ULPs of 4.9406564584124654e-324 ([0.0000000000000000e+00, 9.8813129168249309e-324])
# Floating point matchers: double
ok 419 - 1., WithinULP(nextafter(1., 0.), 1) for: 1.0 is within 1 ULPs of 9.9999999999999989e-01 ([9.9999999999999978e-01, 1.0000000000000000e+00])
# Floating point matchers: double
ok 420 - 1., !WithinULP(nextafter(1., 2.), 0) for: 1.0 not is within 0 ULPs of 1.0000000000000002e+00 ([1.0000000000000002e+00, 1.0000000000000002e+00])
# Floating point matchers: double
ok 421 - 1., WithinULP(1., 0) for: 1.0 is within 0 ULPs of 1.0000000000000000e+00 ([1.0000000000000000e+00, 1.0000000000000000e+00])
# Floating point matchers: double
ok 422 - -0., WithinULP(0., 0) for: -0.0 is within 0 ULPs of 0.0000000000000000e+00 ([0.0000000000000000e+00, 0.0000000000000000e+00])
# Floating point matchers: double
ok 423 - 1., WithinAbs(1., 0.5) || WithinULP(2., 1) for: 1.0 ( is within 0.5 of 1.0 or is within 1 ULPs of 2.0000000000000000e+00 ([1.9999999999999998e+00, 2.0000000000000004e+00]) )
# Floating point matchers: double
ok 424 - 1., WithinAbs(2., 0.5) || WithinULP(1., 0) for: 1.0 ( is within 0.5 of 2.0 or is within 0 ULPs of 1.0000000000000000e+00 ([1.0000000000000000e+00, 1.0000000000000000e+00]) )
# Floating point matchers: double
ok 425 - 0.0001, WithinAbs(0., 0.001) || WithinRel(0., 0.1) for: 0.0001 ( is within 0.001 of 0.0 or and 0 are within 10% of each other )
# Floating point matchers: double
ok 426 - WithinAbs(1., 0.)
# Floating point matchers: double
ok 427 - WithinAbs(1., -1.), std::domain_error
# Floating point matchers: double
ok 428 - WithinULP(1., 0)
# Floating point matchers: double
ok 429 - WithinRel(1., 0.)
# Floating point matchers: double
ok 430 - WithinRel(1., -0.2), std::domain_error
# Floating point matchers: double
ok 431 - WithinRel(1., 1.), std::domain_error
# Floating point matchers: float
ok 432 - 10.f, WithinRel(11.1f, 0.1f) for: 10.0f and 11.1 are within 10% of each other
# Floating point matchers: float
ok 433 - 10.f, !WithinRel(11.2f, 0.1f) for: 10.0f not and 11.2 are within 10% of each other
# Floating point matchers: float
ok 434 - 1.f, !WithinRel(0.f, 0.99f) for: 1.0f not and 0 are within 99% of each other
# Floating point matchers: float
ok 435 - -0.f, WithinRel(0.f) for: -0.0f and 0 are within 0.00119209% of each other
# Floating point matchers: float
ok 436 - v1, WithinRel(v2) for: 0.0f and 1.17549e-38 are within 0.00119209% of each other
# Floating point matchers: float
ok 437 - 1.f, WithinAbs(1.f, 0) for: 1.0f is within 0.0 of 1.0
# Floating point matchers: float
ok 438 - 0.f, WithinAbs(1.f, 1) for: 0.0f is within 1.0 of 1.0
# Floating point matchers: float
ok 439 - 0.f, !WithinAbs(1.f, 0.99f) for: 0.0f not is within 0.9900000095 of 1.0
# Floating point matchers: float
ok 440 - 0.f, !WithinAbs(1.f, 0.99f) for: 0.0f not is within 0.9900000095 of 1.0
# Floating point matchers: float
ok 441 - 0.f, WithinAbs(-0.f, 0) for: 0.0f is within 0.0 of -0.0
# Floating point matchers: float
ok 442 - 11.f, !WithinAbs(10.f, 0.5f) for: 11.0f not is within 0.5 of 10.0
# Floating point matchers: float
ok 443 - 10.f, !WithinAbs(11.f, 0.5f) for: 10.0f not is within 0.5 of 11.0
# Floating point matchers: float
ok 444 - -10.f, WithinAbs(-10.f, 0.5f) for: -10.0f is within 0.5 of -10.0
# Floating point matchers: float
ok 445 - -10.f, WithinAbs(-9.6f, 0.5f) for: -10.0f is within 0.5 of -9.6000003815
# Floating point matchers: float
ok 446 - 1.f, WithinULP(1.f, 0) for: 1.0f is within 0 ULPs of 1.00000000e+00f ([1.00000000e+00, 1.00000000e+00])
# Floating point matchers: float
ok 447 - nextafter(1.f, 2.f), WithinULP(1.f, 1) for: 1.0f is within 1 ULPs of 1.00000000e+00f ([9.99999940e-01, 1.00000012e+00])
# Floating point matchers: float
ok 448 - 0.f, WithinULP(nextafter(0.f, 1.f), 1) for: 0.0f is within 1 ULPs of 1.40129846e-45f ([0.00000000e+00, 2.80259693e-45])
# Floating point matchers: float
ok 449 - 1.f, WithinULP(nextafter(1.f, 0.f), 1) for: 1.0f is within 1 ULPs of 9.99999940e-01f ([9.99999881e-01, 1.00000000e+00])
# Floating point matchers: float
ok 450 - 1.f, !WithinULP(nextafter(1.f, 2.f), 0) for: 1.0f not is within 0 ULPs of 1.00000012e+00f ([1.00000012e+00, 1.00000012e+00])
# Floating point matchers: float
ok 451 - 1.f, WithinULP(1.f, 0) for: 1.0f is within 0 ULPs of 1.00000000e+00f ([1.00000000e+00, 1.00000000e+00])
# Floating point matchers: float
ok 452 - -0.f, WithinULP(0.f, 0) for: -0.0f is within 0 ULPs of 0.00000000e+00f ([0.00000000e+00, 0.00000000e+00])
# Floating point matchers: float
ok 453 - 1.f, WithinAbs(1.f, 0.5) || WithinULP(1.f, 1) for: 1.0f ( is within 0.5 of 1.0 or is within 1 ULPs of 1.00000000e+00f ([9.99999940e-01, 1.00000012e+00]) )
# Floating point matchers: float
ok 454 - 1.f, WithinAbs(2.f, 0.5) || WithinULP(1.f, 0) for: 1.0f ( is within 0.5 of 2.0 or is within 0 ULPs of 1.00000000e+00f ([1.00000000e+00, 1.00000000e+00]) )
# Floating point matchers: float
ok 455 - 0.0001f, WithinAbs(0.f, 0.001f) || WithinRel(0.f, 0.1f) for: 0.0001f ( is within 0.001 of 0.0 or and 0 are within 10% of each other )
# Floating point matchers: float
ok 456 - WithinAbs(1.f, 0.f)
# Floating point matchers: float
ok 457 - WithinAbs(1.f, -1.f), std::domain_error
# Floating point matchers: float
ok 458 - WithinULP(1.f, 0)
# Floating point matchers: float
ok 459 - WithinULP(1.f, static_cast<uint64_t>(-1)), std::domain_error
# Floating point matchers: float
ok 460 - WithinRel(1.f, 0.f)
# Floating point matchers: float
ok 461 - WithinRel(1.f, -0.2f), std::domain_error
# Floating point matchers: float
ok 462 - WithinRel(1.f, 1.f), std::domain_error
# Generators -- adapters
ok 463 - i % 2 == 0 for: 0 == 0
# Generators -- adapters
ok 464 - i % 2 == 0 for: 0 == 0
# Generators -- adapters
ok 465 - i % 2 == 0 for: 0 == 0
# Generators -- adapters
ok 466 - filter([] (int) {return false; }, value(1)), Catch::GeneratorException
# Generators -- adapters
ok 467 - i < 4 for: 1 < 4
# Generators -- adapters
ok 468 - i < 4 for: 2 < 4
# Generators -- adapters
ok 469 - i < 4 for: 3 < 4
# Generators -- adapters
ok 470 - i % 2 == 0 for: 0 == 0
# Generators -- adapters
ok 471 - i % 2 == 0 for: 0 == 0
# Generators -- adapters
ok 472 - i % 2 == 0 for: 0 == 0
# Generators -- adapters
ok 473 - i.size() == 1 for: 1 == 1
# Generators -- adapters
ok 474 - i.size() == 1 for: 1 == 1
# Generators -- adapters
ok 475 - i.size() == 1 for: 1 == 1
# Generators -- adapters
ok 476 - i.size() == 1 for: 1 == 1
# Generators -- adapters
ok 477 - i.size() == 1 for: 1 == 1
# Generators -- adapters
ok 478 - i.size() == 1 for: 1 == 1
# Generators -- adapters
ok 479 - j > 0 for: 1 > 0
# Generators -- adapters
ok 480 - j > 0 for: 2 > 0
# Generators -- adapters
ok 481 - j > 0 for: 3 > 0
# Generators -- adapters
ok 482 - j > 0 for: 1 > 0
# Generators -- adapters
ok 483 - j > 0 for: 2 > 0
# Generators -- adapters
ok 484 - j > 0 for: 3 > 0
# Generators -- adapters
ok 485 - chunk2.size() == 2 for: 2 == 2
# Generators -- adapters
ok 486 - chunk2.front() == chunk2.back() for: 1 == 1
# Generators -- adapters
ok 487 - chunk2.size() == 2 for: 2 == 2
# Generators -- adapters
ok 488 - chunk2.front() == chunk2.back() for: 2 == 2
# Generators -- adapters
ok 489 - chunk2.size() == 2 for: 2 == 2
# Generators -- adapters
ok 490 - chunk2.front() == chunk2.back() for: 3 == 3
# Generators -- adapters
ok 491 - chunk2.size() == 2 for: 2 == 2
# Generators -- adapters
ok 492 - chunk2.front() == chunk2.back() for: 1 == 1
# Generators -- adapters
ok 493 - chunk2.front() < 3 for: 1 < 3
# Generators -- adapters
ok 494 - chunk2.size() == 2 for: 2 == 2
# Generators -- adapters
ok 495 - chunk2.front() == chunk2.back() for: 2 == 2
# Generators -- adapters
ok 496 - chunk2.front() < 3 for: 2 < 3
# Generators -- adapters
ok 497 - chunk2.size() == 0 for: 0 == 0
# Generators -- adapters
ok 498 - chunk2.size() == 0 for: 0 == 0
# Generators -- adapters
ok 499 - chunk2.size() == 0 for: 0 == 0
# Generators -- adapters
ok 500 - chunk(2, value(1)), Catch::GeneratorException
# Generators -- simple
ok 501 - j < i for: -3 < 1
# Generators -- simple
ok 502 - j < i for: -2 < 1
# Generators -- simple
ok 503 - j < i for: -1 < 1
# Generators -- simple
ok 504 - 4u * i > str.size() for: 4 > 1
# Generators -- simple
ok 505 - 4u * i > str.size() for: 4 > 2
# Generators -- simple
ok 506 - 4u * i > str.size() for: 4 > 3
# Generators -- simple
ok 507 - j < i for: -3 < 2
# Generators -- simple
ok 508 - j < i for: -2 < 2
# Generators -- simple
ok 509 - j < i for: -1 < 2
# Generators -- simple
ok 510 - 4u * i > str.size() for: 8 > 1
# Generators -- simple
ok 511 - 4u * i > str.size() for: 8 > 2
# Generators -- simple
ok 512 - 4u * i > str.size() for: 8 > 3
# Generators -- simple
ok 513 - j < i for: -3 < 3
# Generators -- simple
ok 514 - j < i for: -2 < 3
# Generators -- simple
ok 515 - j < i for: -1 < 3
# Generators -- simple
ok 516 - 4u * i > str.size() for: 12 > 1
# Generators -- simple
ok 517 - 4u * i > str.size() for: 12 > 2
# Generators -- simple
ok 518 - 4u * i > str.size() for: 12 > 3
# Generators internals
ok 519 - gen.get() == 123 for: 123 == 123
# Generators internals
ok 520 - !(gen.next()) for: !false
# Generators internals
ok 521 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 522 - gen.next() for: true
# Generators internals
ok 523 - gen.get() == 3 for: 3 == 3
# Generators internals
ok 524 - gen.next() for: true
# Generators internals
ok 525 - gen.get() == 5 for: 5 == 5
# Generators internals
ok 526 - !(gen.next()) for: !false
# Generators internals
ok 527 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 528 - gen.next() for: true
# Generators internals
ok 529 - gen.get() == 5 for: 5 == 5
# Generators internals
ok 530 - gen.next() for: true
# Generators internals
ok 531 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 532 - gen.next() for: true
# Generators internals
ok 533 - gen.get() == 4 for: 4 == 4
# Generators internals
ok 534 - gen.next() for: true
# Generators internals
ok 535 - gen.get() == 0 for: 0 == 0
# Generators internals
ok 536 - !(gen.next()) for: !false
# Generators internals
ok 537 - gen.get().size() == 2 for: 2 == 2
# Generators internals
ok 538 - gen.get() == "aa" for: "aa" == "aa"
# Generators internals
ok 539 - gen.next() for: true
# Generators internals
ok 540 - gen.get() == "bb" for: "bb" == "bb"
# Generators internals
ok 541 - gen.next() for: true
# Generators internals
ok 542 - gen.get() == "cc" for: "cc" == "cc"
# Generators internals
ok 543 - !(gen.next()) for: !false
# Generators internals
ok 544 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 545 - gen.next() for: true
# Generators internals
ok 546 - gen.get() == 3 for: 3 == 3
# Generators internals
ok 547 - !(gen.next()) for: !false
# Generators internals
ok 548 - filter([] (int) { return false; }, value(1)), Catch::GeneratorException
# Generators internals
ok 549 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 550 - gen.next() for: true
# Generators internals
ok 551 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 552 - !(gen.next()) for: !false
# Generators internals
ok 553 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 554 - !(gen.next()) for: !false
# Generators internals
ok 555 - gen.get() == 2.0 for: 2.0 == 2.0
# Generators internals
ok 556 - gen.next() for: true
# Generators internals
ok 557 - gen.get() == 4.0 for: 4.0 == 4.0
# Generators internals
ok 558 - gen.next() for: true
# Generators internals
ok 559 - gen.get() == 6.0 for: 6.0 == 6.0
# Generators internals
ok 560 - !(gen.next()) for: !false
# Generators internals
ok 561 - gen.get() == 2.0 for: 2.0 == 2.0
# Generators internals
ok 562 - gen.next() for: true
# Generators internals
ok 563 - gen.get() == 4.0 for: 4.0 == 4.0
# Generators internals
ok 564 - gen.next() for: true
# Generators internals
ok 565 - gen.get() == 6.0 for: 6.0 == 6.0
# Generators internals
ok 566 - !(gen.next()) for: !false
# Generators internals
ok 567 - gen.get() == 3 for: 3 == 3
# Generators internals
ok 568 - !(gen.next()) for: !false
# Generators internals
ok 569 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 570 - gen.next() for: true
# Generators internals
ok 571 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 572 - gen.next() for: true
# Generators internals
ok 573 - gen.get() == 3 for: 3 == 3
# Generators internals
ok 574 - gen.next() for: true
# Generators internals
ok 575 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 576 - gen.next() for: true
# Generators internals
ok 577 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 578 - gen.next() for: true
# Generators internals
ok 579 - gen.get() == 3 for: 3 == 3
# Generators internals
ok 580 - !(gen.next()) for: !false
# Generators internals
ok 581 - gen.get() == -2 for: -2 == -2
# Generators internals
ok 582 - gen.next() for: true
# Generators internals
ok 583 - gen.get() == -1 for: -1 == -1
# Generators internals
ok 584 - gen.next() for: true
# Generators internals
ok 585 - gen.get() == 0 for: 0 == 0
# Generators internals
ok 586 - gen.next() for: true
# Generators internals
ok 587 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 588 - !(gen.next()) for: !false
# Generators internals
ok 589 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 590 - gen.next() for: true
# Generators internals
ok 591 - gen.get() == 1 for: 1 == 1
# Generators internals
ok 592 - gen.next() for: true
# Generators internals
ok 593 - gen.get() == 0 for: 0 == 0
# Generators internals
ok 594 - gen.next() for: true
# Generators internals
ok 595 - gen.get() == -1 for: -1 == -1
# Generators internals
ok 596 - !(gen.next()) for: !false
# Generators internals
ok 597 - gen.get() == -7 for: -7 == -7
# Generators internals
ok 598 - gen.next() for: true
# Generators internals
ok 599 - gen.get() == -4 for: -4 == -4
# Generators internals
ok 600 - gen.next() for: true
# Generators internals
ok 601 - gen.get() == -1 for: -1 == -1
# Generators internals
ok 602 - gen.next() for: true
# Generators internals
ok 603 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 604 - !(gen.next()) for: !false
# Generators internals
ok 605 - gen.get() == -7 for: -7 == -7
# Generators internals
ok 606 - gen.next() for: true
# Generators internals
ok 607 - gen.get() == -4 for: -4 == -4
# Generators internals
ok 608 - gen.next() for: true
# Generators internals
ok 609 - gen.get() == -1 for: -1 == -1
# Generators internals
ok 610 - gen.next() for: true
# Generators internals
ok 611 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 612 - !(gen.next()) for: !false
# Generators internals
ok 613 - gen.get() == -7 for: -7 == -7
# Generators internals
ok 614 - gen.next() for: true
# Generators internals
ok 615 - gen.get() == -4 for: -4 == -4
# Generators internals
ok 616 - gen.next() for: true
# Generators internals
ok 617 - gen.get() == -1 for: -1 == -1
# Generators internals
ok 618 - gen.next() for: true
# Generators internals
ok 619 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 620 - gen.next() for: true
# Generators internals
ok 621 - gen.get() == 5 for: 5 == 5
# Generators internals
ok 622 - !(gen.next()) for: !false
# Generators internals
ok 623 - gen.get() == Approx(expected) for: -1.0 == Approx( -1.0 ) with 1 message: 'Current expected value is -1'
# Generators internals
ok 624 - gen.next() for: true with 1 message: 'Current expected value is -1'
# Generators internals
ok 625 - gen.get() == Approx(expected) for: -0.9 == Approx( -0.9 ) with 1 message: 'Current expected value is -0.9'
# Generators internals
ok 626 - gen.next() for: true with 1 message: 'Current expected value is -0.9'
# Generators internals
ok 627 - gen.get() == Approx(expected) for: -0.8 == Approx( -0.8 ) with 1 message: 'Current expected value is -0.8'
# Generators internals
ok 628 - gen.next() for: true with 1 message: 'Current expected value is -0.8'
# Generators internals
ok 629 - gen.get() == Approx(expected) for: -0.7 == Approx( -0.7 ) with 1 message: 'Current expected value is -0.7'
# Generators internals
ok 630 - gen.next() for: true with 1 message: 'Current expected value is -0.7'
# Generators internals
ok 631 - gen.get() == Approx(expected) for: -0.6 == Approx( -0.6 ) with 1 message: 'Current expected value is -0.6'
# Generators internals
ok 632 - gen.next() for: true with 1 message: 'Current expected value is -0.6'
# Generators internals
ok 633 - gen.get() == Approx(expected) for: -0.5 == Approx( -0.5 ) with 1 message: 'Current expected value is -0.5'
# Generators internals
ok 634 - gen.next() for: true with 1 message: 'Current expected value is -0.5'
# Generators internals
ok 635 - gen.get() == Approx(expected) for: -0.4 == Approx( -0.4 ) with 1 message: 'Current expected value is -0.4'
# Generators internals
ok 636 - gen.next() for: true with 1 message: 'Current expected value is -0.4'
# Generators internals
ok 637 - gen.get() == Approx(expected) for: -0.3 == Approx( -0.3 ) with 1 message: 'Current expected value is -0.3'
# Generators internals
ok 638 - gen.next() for: true with 1 message: 'Current expected value is -0.3'
# Generators internals
ok 639 - gen.get() == Approx(expected) for: -0.2 == Approx( -0.2 ) with 1 message: 'Current expected value is -0.2'
# Generators internals
ok 640 - gen.next() for: true with 1 message: 'Current expected value is -0.2'
# Generators internals
ok 641 - gen.get() == Approx(expected) for: -0.1 == Approx( -0.1 ) with 1 message: 'Current expected value is -0.1'
# Generators internals
ok 642 - gen.next() for: true with 1 message: 'Current expected value is -0.1'
# Generators internals
ok 643 - gen.get() == Approx(expected) for: -0.0 == Approx( -0.0 ) with 1 message: 'Current expected value is -1.38778e-16'
# Generators internals
ok 644 - gen.next() for: true with 1 message: 'Current expected value is -1.38778e-16'
# Generators internals
ok 645 - gen.get() == Approx(expected) for: 0.1 == Approx( 0.1 ) with 1 message: 'Current expected value is 0.1'
# Generators internals
ok 646 - gen.next() for: true with 1 message: 'Current expected value is 0.1'
# Generators internals
ok 647 - gen.get() == Approx(expected) for: 0.2 == Approx( 0.2 ) with 1 message: 'Current expected value is 0.2'
# Generators internals
ok 648 - gen.next() for: true with 1 message: 'Current expected value is 0.2'
# Generators internals
ok 649 - gen.get() == Approx(expected) for: 0.3 == Approx( 0.3 ) with 1 message: 'Current expected value is 0.3'
# Generators internals
ok 650 - gen.next() for: true with 1 message: 'Current expected value is 0.3'
# Generators internals
ok 651 - gen.get() == Approx(expected) for: 0.4 == Approx( 0.4 ) with 1 message: 'Current expected value is 0.4'
# Generators internals
ok 652 - gen.next() for: true with 1 message: 'Current expected value is 0.4'
# Generators internals
ok 653 - gen.get() == Approx(expected) for: 0.5 == Approx( 0.5 ) with 1 message: 'Current expected value is 0.5'
# Generators internals
ok 654 - gen.next() for: true with 1 message: 'Current expected value is 0.5'
# Generators internals
ok 655 - gen.get() == Approx(expected) for: 0.6 == Approx( 0.6 ) with 1 message: 'Current expected value is 0.6'
# Generators internals
ok 656 - gen.next() for: true with 1 message: 'Current expected value is 0.6'
# Generators internals
ok 657 - gen.get() == Approx(expected) for: 0.7 == Approx( 0.7 ) with 1 message: 'Current expected value is 0.7'
# Generators internals
ok 658 - gen.next() for: true with 1 message: 'Current expected value is 0.7'
# Generators internals
ok 659 - gen.get() == Approx(expected) for: 0.8 == Approx( 0.8 ) with 1 message: 'Current expected value is 0.8'
# Generators internals
ok 660 - gen.next() for: true with 1 message: 'Current expected value is 0.8'
# Generators internals
ok 661 - gen.get() == Approx(expected) for: 0.9 == Approx( 0.9 ) with 1 message: 'Current expected value is 0.9'
# Generators internals
ok 662 - gen.next() for: true with 1 message: 'Current expected value is 0.9'
# Generators internals
ok 663 - gen.get() == Approx( rangeEnd ) for: 1.0 == Approx( 1.0 )
# Generators internals
ok 664 - !(gen.next()) for: !false
# Generators internals
ok 665 - gen.get() == Approx(expected) for: -1.0 == Approx( -1.0 ) with 1 message: 'Current expected value is -1'
# Generators internals
ok 666 - gen.next() for: true with 1 message: 'Current expected value is -1'
# Generators internals
ok 667 - gen.get() == Approx(expected) for: -0.7 == Approx( -0.7 ) with 1 message: 'Current expected value is -0.7'
# Generators internals
ok 668 - gen.next() for: true with 1 message: 'Current expected value is -0.7'
# Generators internals
ok 669 - gen.get() == Approx(expected) for: -0.4 == Approx( -0.4 ) with 1 message: 'Current expected value is -0.4'
# Generators internals
ok 670 - gen.next() for: true with 1 message: 'Current expected value is -0.4'
# Generators internals
ok 671 - gen.get() == Approx(expected) for: -0.1 == Approx( -0.1 ) with 1 message: 'Current expected value is -0.1'
# Generators internals
ok 672 - gen.next() for: true with 1 message: 'Current expected value is -0.1'
# Generators internals
ok 673 - gen.get() == Approx(expected) for: 0.2 == Approx( 0.2 ) with 1 message: 'Current expected value is 0.2'
# Generators internals
ok 674 - gen.next() for: true with 1 message: 'Current expected value is 0.2'
# Generators internals
ok 675 - gen.get() == Approx(expected) for: 0.5 == Approx( 0.5 ) with 1 message: 'Current expected value is 0.5'
# Generators internals
ok 676 - gen.next() for: true with 1 message: 'Current expected value is 0.5'
# Generators internals
ok 677 - !(gen.next()) for: !false
# Generators internals
ok 678 - gen.get() == Approx(expected) for: -1.0 == Approx( -1.0 ) with 1 message: 'Current expected value is -1'
# Generators internals
ok 679 - gen.next() for: true with 1 message: 'Current expected value is -1'
# Generators internals
ok 680 - gen.get() == Approx(expected) for: -0.7 == Approx( -0.7 ) with 1 message: 'Current expected value is -0.7'
# Generators internals
ok 681 - gen.next() for: true with 1 message: 'Current expected value is -0.7'
# Generators internals
ok 682 - gen.get() == Approx(expected) for: -0.4 == Approx( -0.4 ) with 1 message: 'Current expected value is -0.4'
# Generators internals
ok 683 - gen.next() for: true with 1 message: 'Current expected value is -0.4'
# Generators internals
ok 684 - gen.get() == Approx(expected) for: -0.1 == Approx( -0.1 ) with 1 message: 'Current expected value is -0.1'
# Generators internals
ok 685 - gen.next() for: true with 1 message: 'Current expected value is -0.1'
# Generators internals
ok 686 - gen.get() == Approx(expected) for: 0.2 == Approx( 0.2 ) with 1 message: 'Current expected value is 0.2'
# Generators internals
ok 687 - gen.next() for: true with 1 message: 'Current expected value is 0.2'
# Generators internals
ok 688 - gen.get() == Approx(expected) for: 0.5 == Approx( 0.5 ) with 1 message: 'Current expected value is 0.5'
# Generators internals
ok 689 - gen.next() for: true with 1 message: 'Current expected value is 0.5'
# Generators internals
ok 690 - !(gen.next()) for: !false
# Generators internals
ok 691 - gen.get() == 5 for: 5 == 5
# Generators internals
ok 692 - gen.next() for: true
# Generators internals
ok 693 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 694 - gen.next() for: true
# Generators internals
ok 695 - gen.get() == -1 for: -1 == -1
# Generators internals
ok 696 - gen.next() for: true
# Generators internals
ok 697 - gen.get() == -4 for: -4 == -4
# Generators internals
ok 698 - !(gen.next()) for: !false
# Generators internals
ok 699 - gen.get() == 5 for: 5 == 5
# Generators internals
ok 700 - gen.next() for: true
# Generators internals
ok 701 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 702 - gen.next() for: true
# Generators internals
ok 703 - gen.get() == -1 for: -1 == -1
# Generators internals
ok 704 - gen.next() for: true
# Generators internals
ok 705 - gen.get() == -4 for: -4 == -4
# Generators internals
ok 706 - !(gen.next()) for: !false
# Generators internals
ok 707 - gen.get() == 5 for: 5 == 5
# Generators internals
ok 708 - gen.next() for: true
# Generators internals
ok 709 - gen.get() == 2 for: 2 == 2
# Generators internals
ok 710 - gen.next() for: true
# Generators internals
ok 711 - gen.get() == -1 for: -1 == -1
# Generators internals
ok 712 - gen.next() for: true
# Generators internals
ok 713 - gen.get() == -4 for: -4 == -4
# Generators internals
ok 714 - gen.next() for: true
# Generators internals
ok 715 - gen.get() == -7 for: -7 == -7
# Generators internals
ok 716 - !(gen.next()) for: !false
# Greater-than inequalities with different epsilons
ok 717 - d >= Approx( 1.22 ) for: 1.23 >= Approx( 1.22 )
# Greater-than inequalities with different epsilons
ok 718 - d >= Approx( 1.23 ) for: 1.23 >= Approx( 1.23 )
# Greater-than inequalities with different epsilons
ok 719 - !(d >= Approx( 1.24 )) for: !(1.23 >= Approx( 1.24 ))
# Greater-than inequalities with different epsilons
ok 720 - d >= Approx( 1.24 ).epsilon(0.1) for: 1.23 >= Approx( 1.24 )
# INFO and WARN do not abort tests
warning 721 - 'this is a message' with 1 message: 'this is a warning'
# INFO gets logged on failure
not ok 722 - a == 1 for: 2 == 1 with 2 messages: 'this message should be logged' and 'so should this'
# INFO gets logged on failure, even if captured before successful assertions
ok 723 - a == 2 for: 2 == 2 with 1 message: 'this message may be logged later'
# INFO gets logged on failure, even if captured before successful assertions
not ok 724 - a == 1 for: 2 == 1 with 2 messages: 'this message may be logged later' and 'this message should be logged'
# INFO gets logged on failure, even if captured before successful assertions
not ok 725 - a == 0 for: 2 == 0 with 3 messages: 'this message may be logged later' and 'this message should be logged' and 'and this, but later'
# INFO gets logged on failure, even if captured before successful assertions
ok 726 - a == 2 for: 2 == 2 with 4 messages: 'this message may be logged later' and 'this message should be logged' and 'and this, but later' and 'but not this'
# INFO is reset for each loop
ok 727 - i < 10 for: 0 < 10 with 2 messages: 'current counter 0' and 'i := 0'
# INFO is reset for each loop
ok 728 - i < 10 for: 1 < 10 with 2 messages: 'current counter 1' and 'i := 1'
# INFO is reset for each loop
ok 729 - i < 10 for: 2 < 10 with 2 messages: 'current counter 2' and 'i := 2'
# INFO is reset for each loop
ok 730 - i < 10 for: 3 < 10 with 2 messages: 'current counter 3' and 'i := 3'
# INFO is reset for each loop
ok 731 - i < 10 for: 4 < 10 with 2 messages: 'current counter 4' and 'i := 4'
# INFO is reset for each loop
ok 732 - i < 10 for: 5 < 10 with 2 messages: 'current counter 5' and 'i := 5'
# INFO is reset for each loop
ok 733 - i < 10 for: 6 < 10 with 2 messages: 'current counter 6' and 'i := 6'
# INFO is reset for each loop
ok 734 - i < 10 for: 7 < 10 with 2 messages: 'current counter 7' and 'i := 7'
# INFO is reset for each loop
ok 735 - i < 10 for: 8 < 10 with 2 messages: 'current counter 8' and 'i := 8'
# INFO is reset for each loop
ok 736 - i < 10 for: 9 < 10 with 2 messages: 'current counter 9' and 'i := 9'
# INFO is reset for each loop
not ok 737 - i < 10 for: 10 < 10 with 2 messages: 'current counter 10' and 'i := 10'
# Inequality checks that should fail
not ok 738 - data.int_seven != 7 for: 7 != 7
# Inequality checks that should fail
not ok 739 - data.float_nine_point_one != Approx( 9.1f ) for: 9.1f != Approx( 9.1000003815 )
# Inequality checks that should fail
not ok 740 - data.double_pi != Approx( 3.1415926535 ) for: 3.1415926535 != Approx( 3.1415926535 )
# Inequality checks that should fail
not ok 741 - data.str_hello != "hello" for: "hello" != "hello"
# Inequality checks that should fail
not ok 742 - data.str_hello.size() != 5 for: 5 != 5
# Inequality checks that should succeed
ok 743 - data.int_seven != 6 for: 7 != 6
# Inequality checks that should succeed
ok 744 - data.int_seven != 8 for: 7 != 8
# Inequality checks that should succeed
ok 745 - data.float_nine_point_one != Approx( 9.11f ) for: 9.1f != Approx( 9.1099996567 )
# Inequality checks that should succeed
ok 746 - data.float_nine_point_one != Approx( 9.0f ) for: 9.1f != Approx( 9.0 )
# Inequality checks that should succeed
ok 747 - data.float_nine_point_one != Approx( 1 ) for: 9.1f != Approx( 1.0 )
# Inequality checks that should succeed
ok 748 - data.float_nine_point_one != Approx( 0 ) for: 9.1f != Approx( 0.0 )
# Inequality checks that should succeed
ok 749 - data.double_pi != Approx( 3.1415 ) for: 3.1415926535 != Approx( 3.1415 )
# Inequality checks that should succeed
ok 750 - data.str_hello != "goodbye" for: "hello" != "goodbye"
# Inequality checks that should succeed
ok 751 - data.str_hello != "hell" for: "hello" != "hell"
# Inequality checks that should succeed
ok 752 - data.str_hello != "hello1" for: "hello" != "hello1"
# Inequality checks that should succeed
ok 753 - data.str_hello.size() != 6 for: 5 != 6
# Less-than inequalities with different epsilons
ok 754 - d <= Approx( 1.24 ) for: 1.23 <= Approx( 1.24 )
# Less-than inequalities with different epsilons
ok 755 - d <= Approx( 1.23 ) for: 1.23 <= Approx( 1.23 )
# Less-than inequalities with different epsilons
ok 756 - !(d <= Approx( 1.22 )) for: !(1.23 <= Approx( 1.22 ))
# Less-than inequalities with different epsilons
ok 757 - d <= Approx( 1.22 ).epsilon(0.1) for: 1.23 <= Approx( 1.22 )
# ManuallyRegistered
ok 758 - with 1 message: 'was called'
# Matchers can be (AllOf) composed with the && operator
ok 759 - testStringForMatching(), Contains("string") && Contains("abc") && Contains("substring") && Contains("contains") for: "this string contains 'abc' as a substring" ( contains: "string" and contains: "abc" and contains: "substring" and contains: "contains" )
# Matchers can be (AnyOf) composed with the || operator
ok 760 - testStringForMatching(), Contains("string") || Contains("different") || Contains("random") for: "this string contains 'abc' as a substring" ( contains: "string" or contains: "different" or contains: "random" )
# Matchers can be (AnyOf) composed with the || operator
ok 761 - testStringForMatching2(), Contains("string") || Contains("different") || Contains("random") for: "some completely different text that contains one common word" ( contains: "string" or contains: "different" or contains: "random" )
# Matchers can be composed with both && and ||
ok 762 - testStringForMatching(), (Contains("string") || Contains("different")) && Contains("substring") for: "this string contains 'abc' as a substring" ( ( contains: "string" or contains: "different" ) and contains: "substring" )
# Matchers can be composed with both && and || - failing
not ok 763 - testStringForMatching(), (Contains("string") || Contains("different")) && Contains("random") for: "this string contains 'abc' as a substring" ( ( contains: "string" or contains: "different" ) and contains: "random" )
# Matchers can be negated (Not) with the ! operator
ok 764 - testStringForMatching(), !Contains("different") for: "this string contains 'abc' as a substring" not contains: "different"
# Matchers can be negated (Not) with the ! operator - failing
not ok 765 - testStringForMatching(), !Contains("substring") for: "this string contains 'abc' as a substring" not contains: "substring"
# Mismatching exception messages failing the test
ok 766 - thisThrows(), "expected exception" for: "expected exception" equals: "expected exception"
# Mismatching exception messages failing the test
not ok 767 - thisThrows(), "should fail" for: "expected exception" equals: "should fail"
# Nested generators and captured variables
ok 768 - values > -6 for: 3 > -6
# Nested generators and captured variables
ok 769 - values > -6 for: 4 > -6
# Nested generators and captured variables
ok 770 - values > -6 for: 5 > -6
# Nested generators and captured variables
ok 771 - values > -6 for: 6 > -6
# Nested generators and captured variables
ok 772 - values > -6 for: -5 > -6
# Nested generators and captured variables
ok 773 - values > -6 for: -4 > -6
# Nested generators and captured variables
ok 774 - values > -6 for: 90 > -6
# Nested generators and captured variables
ok 775 - values > -6 for: 91 > -6
# Nested generators and captured variables
ok 776 - values > -6 for: 92 > -6
# Nested generators and captured variables
ok 777 - values > -6 for: 93 > -6
# Nested generators and captured variables
ok 778 - values > -6 for: 94 > -6
# Nested generators and captured variables
ok 779 - values > -6 for: 95 > -6
# Nested generators and captured variables
ok 780 - values > -6 for: 96 > -6
# Nested generators and captured variables
ok 781 - values > -6 for: 97 > -6
# Nested generators and captured variables
ok 782 - values > -6 for: 98 > -6
# Nested generators and captured variables
ok 783 - values > -6 for: 99 > -6
# Nice descriptive name
warning 784 - 'This one ran'
# Non-std exceptions can be translated
not ok 785 - unexpected exception with message: 'custom exception'
# Objects that evaluated in boolean contexts can be checked
ok 786 - True for: {?}
# Objects that evaluated in boolean contexts can be checked
ok 787 - !False for: true
# Objects that evaluated in boolean contexts can be checked
ok 788 - !(False) for: !{?}
# Optionally static assertions
ok 789 - with 1 message: 'std::is_void<void>::value'
# Optionally static assertions
ok 790 - with 1 message: '!(std::is_void<int>::value)'
# Ordering comparison checks that should fail
not ok 791 - data.int_seven > 7 for: 7 > 7
# Ordering comparison checks that should fail
not ok 792 - data.int_seven < 7 for: 7 < 7
# Ordering comparison checks that should fail
not ok 793 - data.int_seven > 8 for: 7 > 8
# Ordering comparison checks that should fail
not ok 794 - data.int_seven < 6 for: 7 < 6
# Ordering comparison checks that should fail
not ok 795 - data.int_seven < 0 for: 7 < 0
# Ordering comparison checks that should fail
not ok 796 - data.int_seven < -1 for: 7 < -1
# Ordering comparison checks that should fail
not ok 797 - data.int_seven >= 8 for: 7 >= 8
# Ordering comparison checks that should fail
not ok 798 - data.int_seven <= 6 for: 7 <= 6
# Ordering comparison checks that should fail
not ok 799 - data.float_nine_point_one < 9 for: 9.1f < 9
# Ordering comparison checks that should fail
not ok 800 - data.float_nine_point_one > 10 for: 9.1f > 10
# Ordering comparison checks that should fail
not ok 801 - data.float_nine_point_one > 9.2 for: 9.1f > 9.2
# Ordering comparison checks that should fail
not ok 802 - data.str_hello > "hello" for: "hello" > "hello"
# Ordering comparison checks that should fail
not ok 803 - data.str_hello < "hello" for: "hello" < "hello"
# Ordering comparison checks that should fail
not ok 804 - data.str_hello > "hellp" for: "hello" > "hellp"
# Ordering comparison checks that should fail
not ok 805 - data.str_hello > "z" for: "hello" > "z"
# Ordering comparison checks that should fail
not ok 806 - data.str_hello < "hellm" for: "hello" < "hellm"
# Ordering comparison checks that should fail
not ok 807 - data.str_hello < "a" for: "hello" < "a"
# Ordering comparison checks that should fail
not ok 808 - data.str_hello >= "z" for: "hello" >= "z"
# Ordering comparison checks that should fail
not ok 809 - data.str_hello <= "a" for: "hello" <= "a"
# Ordering comparison checks that should succeed
ok 810 - data.int_seven < 8 for: 7 < 8
# Ordering comparison checks that should succeed
ok 811 - data.int_seven > 6 for: 7 > 6
# Ordering comparison checks that should succeed
ok 812 - data.int_seven > 0 for: 7 > 0
# Ordering comparison checks that should succeed
ok 813 - data.int_seven > -1 for: 7 > -1
# Ordering comparison checks that should succeed
ok 814 - data.int_seven >= 7 for: 7 >= 7
# Ordering comparison checks that should succeed
ok 815 - data.int_seven >= 6 for: 7 >= 6
# Ordering comparison checks that should succeed
ok 816 - data.int_seven <= 7 for: 7 <= 7
# Ordering comparison checks that should succeed
ok 817 - data.int_seven <= 8 for: 7 <= 8
# Ordering comparison checks that should succeed
ok 818 - data.float_nine_point_one > 9 for: 9.1f > 9
# Ordering comparison checks that should succeed
ok 819 - data.float_nine_point_one < 10 for: 9.1f < 10
# Ordering comparison checks that should succeed
ok 820 - data.float_nine_point_one < 9.2 for: 9.1f < 9.2
# Ordering comparison checks that should succeed
ok 821 - data.str_hello <= "hello" for: "hello" <= "hello"
# Ordering comparison checks that should succeed
ok 822 - data.str_hello >= "hello" for: "hello" >= "hello"
# Ordering comparison checks that should succeed
ok 823 - data.str_hello < "hellp" for: "hello" < "hellp"
# Ordering comparison checks that should succeed
ok 824 - data.str_hello < "zebra" for: "hello" < "zebra"
# Ordering comparison checks that should succeed
ok 825 - data.str_hello > "hellm" for: "hello" > "hellm"
# Ordering comparison checks that should succeed
ok 826 - data.str_hello > "a" for: "hello" > "a"
# Our PCG implementation provides expected results for known seeds
ok 827 - rng() == 0x<hex digits> for: 4242248763 (0x<hex digits>) == 4242248763 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 828 - rng() == 0x<hex digits> for: 1867888929 (0x<hex digits>) == 1867888929 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 829 - rng() == 0x<hex digits> for: 1276619030 (0x<hex digits>) == 1276619030 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 830 - rng() == 0x<hex digits> for: 1911218783 (0x<hex digits>) == 1911218783 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 831 - rng() == 0x<hex digits> for: 1827115164 (0x<hex digits>) == 1827115164 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 832 - rng() == 0x<hex digits> for: 1472234645 (0x<hex digits>) == 1472234645 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 833 - rng() == 0x<hex digits> for: 868832940 (0x<hex digits>) == 868832940 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 834 - rng() == 0x<hex digits> for: 570883446 (0x<hex digits>) == 570883446 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 835 - rng() == 0x<hex digits> for: 889299803 (0x<hex digits>) == 889299803 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 836 - rng() == 0x<hex digits> for: 4261393167 (0x<hex digits>) == 4261393167 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 837 - rng() == 0x<hex digits> for: 1472234645 (0x<hex digits>) == 1472234645 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 838 - rng() == 0x<hex digits> for: 868832940 (0x<hex digits>) == 868832940 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 839 - rng() == 0x<hex digits> for: 570883446 (0x<hex digits>) == 570883446 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 840 - rng() == 0x<hex digits> for: 889299803 (0x<hex digits>) == 889299803 (0x<hex digits>)
# Our PCG implementation provides expected results for known seeds
ok 841 - rng() == 0x<hex digits> for: 4261393167 (0x<hex digits>) == 4261393167 (0x<hex digits>)
# Output from all sections is reported
not ok 842 - explicitly with 1 message: 'Message from section one'
# Output from all sections is reported
not ok 843 - explicitly with 1 message: 'Message from section two'
# Parse test names and tags
ok 844 - spec.hasFilters() == false for: false == false
# Parse test names and tags
ok 845 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 846 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 847 - spec.hasFilters() == false for: false == false
# Parse test names and tags
ok 848 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 849 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 850 - spec.hasFilters() == false for: false == false
# Parse test names and tags
ok 851 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 852 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 853 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 854 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 855 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 856 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 857 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 858 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 859 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 860 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 861 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 862 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 863 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 864 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 865 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 866 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 867 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 868 - parseTestSpec( "*a" ).matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 869 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 870 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 871 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 872 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 873 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 874 - parseTestSpec( "a*" ).matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 875 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 876 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 877 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 878 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 879 - spec.matches( *tcD ) == true for: true == true
# Parse test names and tags
ok 880 - parseTestSpec( "*a*" ).matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 881 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 882 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 883 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 884 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 885 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 886 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 887 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 888 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 889 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 890 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 891 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 892 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 893 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 894 - spec.matches( *tcD ) == true for: true == true
# Parse test names and tags
ok 895 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 896 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 897 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 898 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 899 - spec.matches( *tcD ) == true for: true == true
# Parse test names and tags
ok 900 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 901 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 902 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 903 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 904 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 905 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 906 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 907 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 908 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 909 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 910 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 911 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 912 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 913 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 914 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 915 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 916 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 917 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 918 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 919 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 920 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 921 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 922 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 923 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 924 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 925 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 926 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 927 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 928 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 929 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 930 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 931 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 932 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 933 - spec.matches( *tcD ) == true for: true == true
# Parse test names and tags
ok 934 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 935 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 936 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 937 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 938 - spec.matches( *tcD ) == true for: true == true
# Parse test names and tags
ok 939 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 940 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 941 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 942 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 943 - spec.matches( *tcD ) == true for: true == true
# Parse test names and tags
ok 944 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 945 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 946 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 947 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 948 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 949 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 950 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 951 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 952 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 953 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 954 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 955 - spec.matches( *tcA ) == true for: true == true
# Parse test names and tags
ok 956 - spec.matches( *tcB ) == true for: true == true
# Parse test names and tags
ok 957 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 958 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 959 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 960 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 961 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 962 - spec.matches( *tcC ) == true for: true == true
# Parse test names and tags
ok 963 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 964 - spec.hasFilters() == false for: false == false
# Parse test names and tags
ok 965 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 966 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 967 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 968 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 969 - spec.hasFilters() == false for: false == false
# Parse test names and tags
ok 970 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 971 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 972 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 973 - spec.matches( *tcD ) == false for: false == false
# Parse test names and tags
ok 974 - spec.hasFilters() == true for: true == true
# Parse test names and tags
ok 975 - spec.matches( *tcA ) == false for: false == false
# Parse test names and tags
ok 976 - spec.matches( *tcB ) == false for: false == false
# Parse test names and tags
ok 977 - spec.matches( *tcC ) == false for: false == false
# Parse test names and tags
ok 978 - spec.matches( *tcD ) == true for: true == true
# Parse test names and tags
ok 979 - spec.matches( *fakeTestCase( "  aardvark " ) ) for: true
# Parse test names and tags
ok 980 - spec.matches( *fakeTestCase( "  aardvark" ) ) for: true
# Parse test names and tags
ok 981 - spec.matches( *fakeTestCase( " aardvark " ) ) for: true
# Parse test names and tags
ok 982 - spec.matches( *fakeTestCase( "aardvark " ) ) for: true
# Parse test names and tags
ok 983 - spec.matches( *fakeTestCase( "aardvark" ) ) for: true
# Parse test names and tags
ok 984 - spec.matches( *fakeTestCase( "  aardvark " ) ) for: true
# Parse test names and tags
ok 985 - spec.matches( *fakeTestCase( "  aardvark" ) ) for: true
# Parse test names and tags
ok 986 - spec.matches( *fakeTestCase( " aardvark " ) ) for: true
# Parse test names and tags
ok 987 - spec.matches( *fakeTestCase( "aardvark " ) ) for: true
# Parse test names and tags
ok 988 - spec.matches( *fakeTestCase( "aardvark" ) ) for: true
# Pointers can be compared to null
ok 989 - p == 0 for: 0 == 0
# Pointers can be compared to null
ok 990 - p == pNULL for: 0 == 0
# Pointers can be compared to null
ok 991 - p != 0 for: 0x<hex digits> != 0
# Pointers can be compared to null
ok 992 - cp != 0 for: 0x<hex digits> != 0
# Pointers can be compared to null
ok 993 - cpc != 0 for: 0x<hex digits> != 0
# Pointers can be compared to null
ok 994 - returnsNull() == 0 for: {null string} == 0
# Pointers can be compared to null
ok 995 - returnsConstNull() == 0 for: {null string} == 0
# Pointers can be compared to null
ok 996 - 0 != p for: 0 != 0x<hex digits>
# Precision of floating point stringification can be set
ok 997 - str1.size() == 3 + 5 for: 8 == 8
# Precision of floating point stringification can be set
ok 998 - str2.size() == 3 + 10 for: 13 == 13
# Precision of floating point stringification can be set
ok 999 - str1.size() == 2 + 5 for: 7 == 7
# Precision of floating point stringification can be set
ok 1000 - str2.size() == 2 + 15 for: 17 == 17
# Predicate matcher can accept const char*
ok 1001 - "foo", Predicate<const char*>([] (const char* const&) { return true; }) for: "foo" matches undescribed predicate
# Process can be configured on command line
ok 1002 - result for: {?}
# Process can be configured on command line
ok 1003 - config.processName == "" for: "" == ""
# Process can be configured on command line
ok 1004 - result for: {?}
# Process can be configured on command line
ok 1005 - config.processName == "test" for: "test" == "test"
# Process can be configured on command line
ok 1006 - config.shouldDebugBreak == false for: false == false
# Process can be configured on command line
ok 1007 - config.abortAfter == -1 for: -1 == -1
# Process can be configured on command line
ok 1008 - config.noThrow == false for: false == false
# Process can be configured on command line
ok 1009 - config.reporterName == "console" for: "console" == "console"
# Process can be configured on command line
ok 1010 - !(cfg.hasTestFilters()) for: !false
# Process can be configured on command line
ok 1011 - result for: {?}
# Process can be configured on command line
ok 1012 - cfg.hasTestFilters() for: true
# Process can be configured on command line
ok 1013 - cfg.testSpec().matches(*fakeTestCase("notIncluded")) == false for: false == false
# Process can be configured on command line
ok 1014 - cfg.testSpec().matches(*fakeTestCase("test1")) for: true
# Process can be configured on command line
ok 1015 - result for: {?}
# Process can be configured on command line
ok 1016 - cfg.hasTestFilters() for: true
# Process can be configured on command line
ok 1017 - cfg.testSpec().matches(*fakeTestCase("test1")) == false for: false == false
# Process can be configured on command line
ok 1018 - cfg.testSpec().matches(*fakeTestCase("alwaysIncluded")) for: true
# Process can be configured on command line
ok 1019 - result for: {?}
# Process can be configured on command line
ok 1020 - cfg.hasTestFilters() for: true
# Process can be configured on command line
ok 1021 - cfg.testSpec().matches(*fakeTestCase("test1")) == false for: false == false
# Process can be configured on command line
ok 1022 - cfg.testSpec().matches(*fakeTestCase("alwaysIncluded")) for: true
# Process can be configured on command line
ok 1023 - cli.parse({"test", "-r", "console"}) for: {?}
# Process can be configured on command line
ok 1024 - config.reporterName == "console" for: "console" == "console"
# Process can be configured on command line
ok 1025 - cli.parse({"test", "-r", "xml"}) for: {?}
# Process can be configured on command line
ok 1026 - config.reporterName == "xml" for: "xml" == "xml"
# Process can be configured on command line
ok 1027 - cli.parse({"test", "--reporter", "junit"}) for: {?}
# Process can be configured on command line
ok 1028 - config.reporterName == "junit" for: "junit" == "junit"
# Process can be configured on command line
ok 1029 - !(cli.parse({ "test", "-r", "xml", "-r", "junit" })) for: !{?}
# Process can be configured on command line
ok 1030 - !result for: true
# Process can be configured on command line
ok 1031 - result.errorMessage(), Contains("Unrecognized reporter") for: "Unrecognized reporter, 'unsupported'. Check available with --list-reporters" contains: "Unrecognized reporter"
# Process can be configured on command line
ok 1032 - cli.parse({"test", "-b"}) for: {?}
# Process can be configured on command line
ok 1033 - config.shouldDebugBreak == true for: true == true
# Process can be configured on command line
ok 1034 - cli.parse({"test", "--break"}) for: {?}
# Process can be configured on command line
ok 1035 - config.shouldDebugBreak for: true
# Process can be configured on command line
ok 1036 - cli.parse({"test", "-a"}) for: {?}
# Process can be configured on command line
ok 1037 - config.abortAfter == 1 for: 1 == 1
# Process can be configured on command line
ok 1038 - cli.parse({"test", "-x", "2"}) for: {?}
# Process can be configured on command line
ok 1039 - config.abortAfter == 2 for: 2 == 2
# Process can be configured on command line
ok 1040 - !result for: true
# Process can be configured on command line
ok 1041 - result.errorMessage(), Contains("convert") && Contains("oops") for: "Unable to convert 'oops' to destination type" ( contains: "convert" and contains: "oops" )
# Process can be configured on command line
ok 1042 - cli.parse({"test", "-e"}) for: {?}
# Process can be configured on command line
ok 1043 - config.noThrow for: true
# Process can be configured on command line
ok 1044 - cli.parse({"test", "--nothrow"}) for: {?}
# Process can be configured on command line
ok 1045 - config.noThrow for: true
# Process can be configured on command line
ok 1046 - cli.parse({"test", "-o", "filename.ext"}) for: {?}
# Process can be configured on command line
ok 1047 - config.outputFilename == "filename.ext" for: "filename.ext" == "filename.ext"
# Process can be configured on command line
ok 1048 - cli.parse({"test", "--out", "filename.ext"}) for: {?}
# Process can be configured on command line
ok 1049 - config.outputFilename == "filename.ext" for: "filename.ext" == "filename.ext"
# Process can be configured on command line
ok 1050 - cli.parse({"test", "-abe"}) for: {?}
# Process can be configured on command line
ok 1051 - config.abortAfter == 1 for: 1 == 1
# Process can be configured on command line
ok 1052 - config.shouldDebugBreak for: true
# Process can be configured on command line
ok 1053 - config.noThrow == true for: true == true
# Process can be configured on command line
ok 1054 - cli.parse({"test"}) for: {?}
# Process can be configured on command line
ok 1055 - config.useColour == UseColour::Auto for: 0 == 0
# Process can be configured on command line
ok 1056 - cli.parse({"test", "--use-colour", "auto"}) for: {?}
# Process can be configured on command line
ok 1057 - config.useColour == UseColour::Auto for: 0 == 0
# Process can be configured on command line
ok 1058 - cli.parse({"test", "--use-colour", "yes"}) for: {?}
# Process can be configured on command line
ok 1059 - config.useColour == UseColour::Yes for: 1 == 1
# Process can be configured on command line
ok 1060 - cli.parse({"test", "--use-colour", "no"}) for: {?}
# Process can be configured on command line
ok 1061 - config.useColour == UseColour::No for: 2 == 2
# Process can be configured on command line
ok 1062 - !result for: true
# Process can be configured on command line
ok 1063 - result.errorMessage(), Contains( "colour mode must be one of" ) for: "colour mode must be one of: auto, yes or no. 'wrong' not recognised" contains: "colour mode must be one of"
# Process can be configured on command line
ok 1064 - cli.parse({ "test", "--benchmark-samples=200" }) for: {?}
# Process can be configured on command line
ok 1065 - config.benchmarkSamples == 200 for: 200 == 200
# Process can be configured on command line
ok 1066 - cli.parse({ "test", "--benchmark-resamples=20000" }) for: {?}
# Process can be configured on command line
ok 1067 - config.benchmarkResamples == 20000 for: 20000 (0x<hex digits>) == 20000 (0x<hex digits>)
# Process can be configured on command line
ok 1068 - cli.parse({ "test", "--benchmark-confidence-interval=0.99" }) for: {?}
# Process can be configured on command line
ok 1069 - config.benchmarkConfidenceInterval == Catch::Detail::Approx(0.99) for: 0.99 == Approx( 0.99 )
# Process can be configured on command line
ok 1070 - cli.parse({ "test", "--benchmark-no-analysis" }) for: {?}
# Process can be configured on command line
ok 1071 - config.benchmarkNoAnalysis for: true
# Product with differing arities - std::tuple<int, double, float>
ok 1072 - std::tuple_size<TestType>::value >= 1 for: 3 >= 1
# Product with differing arities - std::tuple<int, double>
ok 1073 - std::tuple_size<TestType>::value >= 1 for: 2 >= 1
# Product with differing arities - std::tuple<int>
ok 1074 - std::tuple_size<TestType>::value >= 1 for: 1 >= 1
# Reconstruction should be based on stringification: #914
not ok 1075 - truthy(false) for: Hey, its truthy!
# Regex string matcher
not ok 1076 - testStringForMatching(), Matches("this STRING contains 'abc' as a substring") for: "this string contains 'abc' as a substring" matches "this STRING contains 'abc' as a substring" case sensitively
# Regex string matcher
not ok 1077 - testStringForMatching(), Matches("contains 'abc' as a substring") for: "this string contains 'abc' as a substring" matches "contains 'abc' as a substring" case sensitively
# Regex string matcher
not ok 1078 - testStringForMatching(), Matches("this string contains 'abc' as a") for: "this string contains 'abc' as a substring" matches "this string contains 'abc' as a" case sensitively
# Regression test #1
ok 1079 - actual, !UnorderedEquals(expected) for: { 'a', 'b' } not UnorderedEquals: { 'c', 'b' }
# SUCCEED counts as a test pass
ok 1080 - with 1 message: 'this is a success'
# SUCCEED does not require an argument
ok 1081 -
# Scenario: BDD tests requiring Fixtures to provide commonly-accessed data or methods
ok 1082 - before == 0 for: 0 == 0
# Scenario: BDD tests requiring Fixtures to provide commonly-accessed data or methods
ok 1083 - after > before for: 1 > 0
# Scenario: Do that thing with the thing
ok 1084 - itDoesThis() for: true
# Scenario: Do that thing with the thing
ok 1085 - itDoesThat() for: true
# Scenario: This is a really long scenario name to see how the list command deals with wrapping
ok 1086 - with 1 message: 'boo!'
# Scenario: Vector resizing affects size and capacity
ok 1087 - v.size() == 0 for: 0 == 0
# Scenario: Vector resizing affects size and capacity
ok 1088 - v.size() == 10 for: 10 == 10
# Scenario: Vector resizing affects size and capacity
ok 1089 - v.capacity() >= 10 for: 10 >= 10
# Scenario: Vector resizing affects size and capacity
ok 1090 - v.size() == 5 for: 5 == 5
# Scenario: Vector resizing affects size and capacity
ok 1091 - v.capacity() >= 10 for: 10 >= 10
# Scenario: Vector resizing affects size and capacity
ok 1092 - v.size() == 0 for: 0 == 0
# Scenario: Vector resizing affects size and capacity
ok 1093 - v.capacity() >= 10 for: 10 >= 10
# Scenario: Vector resizing affects size and capacity
ok 1094 - v.size() == 0 for: 0 == 0
A string sent directly to stdout
A string sent directly to stderr
A string sent to stderr via clog
# Some simple comparisons between doubles
ok 1095 - d == Approx( 1.23 ) for: 1.23 == Approx( 1.23 )
# Some simple comparisons between doubles
ok 1096 - d != Approx( 1.22 ) for: 1.23 != Approx( 1.22 )
# Some simple comparisons between doubles
ok 1097 - d != Approx( 1.24 ) for: 1.23 != Approx( 1.24 )
# Some simple comparisons between doubles
ok 1098 - d == 1.23_a for: 1.23 == Approx( 1.23 )
# Some simple comparisons between doubles
ok 1099 - d != 1.22_a for: 1.23 != Approx( 1.22 )
# Some simple comparisons between doubles
ok 1100 - Approx( d ) == 1.23 for: Approx( 1.23 ) == 1.23
# Some simple comparisons between doubles
ok 1101 - Approx( d ) != 1.22 for: Approx( 1.23 ) != 1.22
# Some simple comparisons between doubles
ok 1102 - Approx( d ) != 1.24 for: Approx( 1.23 ) != 1.24
Message from section one
Message from section two
# StartsWith string matcher
not ok 1103 - testStringForMatching(), StartsWith("This String") for: "this string contains 'abc' as a substring" starts with: "This String"
# StartsWith string matcher
not ok 1104 - testStringForMatching(), StartsWith("string", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" starts with: "string" (case insensitive)
# Static arrays are convertible to string
ok 1105 - Catch::Detail::stringify(singular) == "{ 1 }" for: "{ 1 }" == "{ 1 }"
# Static arrays are convertible to string
ok 1106 - Catch::Detail::stringify(arr) == "{ 3, 2, 1 }" for: "{ 3, 2, 1 }" == "{ 3, 2, 1 }"
# Static arrays are convertible to string
ok 1107 - Catch::Detail::stringify(arr) == R"({ { "1:1", "1:2", "1:3" }, { "2:1", "2:2" } })" for: "{ { "1:1", "1:2", "1:3" }, { "2:1", "2:2" } }" == "{ { "1:1", "1:2", "1:3" }, { "2:1", "2:2" } }"
# String matchers
ok 1108 - testStringForMatching(), Contains("string") for: "this string contains 'abc' as a substring" contains: "string"
# String matchers
ok 1109 - testStringForMatching(), Contains("string", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" contains: "string" (case insensitive)
# String matchers
ok 1110 - testStringForMatching(), Contains("abc") for: "this string contains 'abc' as a substring" contains: "abc"
# String matchers
ok 1111 - testStringForMatching(), Contains("aBC", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" contains: "abc" (case insensitive)
# String matchers
ok 1112 - testStringForMatching(), StartsWith("this") for: "this string contains 'abc' as a substring" starts with: "this"
# String matchers
ok 1113 - testStringForMatching(), StartsWith("THIS", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" starts with: "this" (case insensitive)
# String matchers
ok 1114 - testStringForMatching(), EndsWith("substring") for: "this string contains 'abc' as a substring" ends with: "substring"
# String matchers
ok 1115 - testStringForMatching(), EndsWith(" SuBsTrInG", Catch::CaseSensitive::No) for: "this string contains 'abc' as a substring" ends with: " substring" (case insensitive)
# StringRef
ok 1116 - empty.empty() for: true
# StringRef
ok 1117 - empty.size() == 0 for: 0 == 0
# StringRef
ok 1118 - empty.isNullTerminated() for: true
# StringRef
ok 1119 - std::strcmp( empty.c_str(), "" ) == 0 for: 0 == 0
# StringRef
ok 1120 - s.empty() == false for: false == false
# StringRef
ok 1121 - s.size() == 5 for: 5 == 5
# StringRef
ok 1122 - s.isNullTerminated() for: true
# StringRef
ok 1123 - std::strcmp( rawChars, "hello" ) == 0 for: 0 == 0
# StringRef
ok 1124 - s.c_str()
# StringRef
ok 1125 - s.c_str() == rawChars for: "hello" == "hello"
# StringRef
ok 1126 - s.data() == rawChars for: "hello" == "hello"
# StringRef
ok 1127 - original == "original"
# StringRef
ok 1128 - !(original.isNullTerminated()) for: !false
# StringRef
ok 1129 - original.c_str()
# StringRef
ok 1130 - original.data()
# StringRef
ok 1131 - ss.empty() == false for: false == false
# StringRef
ok 1132 - ss.size() == 5 for: 5 == 5
# StringRef
ok 1133 - std::strncmp( ss.data(), "hello", 5 ) == 0 for: 0 == 0
# StringRef
ok 1134 - ss == "hello" for: hello == "hello"
# StringRef
ok 1135 - ss.size() == 6 for: 6 == 6
# StringRef
ok 1136 - std::strcmp( ss.c_str(), "world!" ) == 0 for: 0 == 0
# StringRef
ok 1137 - s.data() == s2.data() for: "hello world!" == "hello world!"
# StringRef
ok 1138 - s.data() == ss.data() for: "hello world!" == "hello world!"
# StringRef
ok 1139 - s.substr(s.size() + 1, 123).empty() for: true
# StringRef
ok 1140 - std::strcmp(ss.c_str(), "world!") == 0 for: 0 == 0
# StringRef
ok 1141 - (char*)buffer1 != (char*)buffer2 for: "Hello" != "Hello"
# StringRef
ok 1142 - left == right for: Hello == Hello
# StringRef
ok 1143 - left != left.substr(0, 3) for: Hello != Hel
# StringRef
ok 1144 - sr == "a standard string" for: a standard string == "a standard string"
# StringRef
ok 1145 - sr.size() == stdStr.size() for: 17 == 17
# StringRef
ok 1146 - sr == "a standard string" for: a standard string == "a standard string"
# StringRef
ok 1147 - sr.size() == stdStr.size() for: 17 == 17
# StringRef
ok 1148 - sr == "a standard string" for: a standard string == "a standard string"
# StringRef
ok 1149 - sr.size() == stdStr.size() for: 17 == 17
# StringRef
ok 1150 - stdStr == "a stringref" for: "a stringref" == "a stringref"
# StringRef
ok 1151 - stdStr.size() == sr.size() for: 11 == 11
# StringRef
ok 1152 - stdStr == "a stringref" for: "a stringref" == "a stringref"
# StringRef
ok 1153 - stdStr.size() == sr.size() for: 11 == 11
# StringRef at compilation time
ok 1154 - with 1 message: 'StringRef{}.size() == 0'
# StringRef at compilation time
ok 1155 - with 1 message: 'StringRef{ "abc", 3 }.size() == 3'
# StringRef at compilation time
ok 1156 - with 1 message: 'StringRef{ "abc", 3 }.isNullTerminated()'
# StringRef at compilation time
ok 1157 - with 1 message: 'StringRef{ "abc", 2 }.size() == 2'
# StringRef at compilation time
ok 1158 - with 1 message: '!(StringRef{ "abc", 2 }.isNullTerminated())'
# StringRef at compilation time
ok 1159 - with 1 message: '!(sr1.empty())'
# StringRef at compilation time
ok 1160 - with 1 message: 'sr1.size() == 3'
# StringRef at compilation time
ok 1161 - with 1 message: 'sr1.isNullTerminated()'
# StringRef at compilation time
ok 1162 - with 1 message: 'sr2.empty()'
# StringRef at compilation time
ok 1163 - with 1 message: 'sr2.size() == 0'
# StringRef at compilation time
ok 1164 - with 1 message: 'sr2.isNullTerminated()'
# Stringifying std::chrono::duration helpers
ok 1165 - minute == seconds for: 1 m == 60 s
# Stringifying std::chrono::duration helpers
ok 1166 - hour != seconds for: 1 h != 60 s
# Stringifying std::chrono::duration helpers
ok 1167 - micro != milli for: 1 us != 1 ms
# Stringifying std::chrono::duration helpers
ok 1168 - nano != micro for: 1 ns != 1 us
# Stringifying std::chrono::duration with weird ratios
ok 1169 - half_minute != femto_second for: 1 [30/1]s != 1 fs
# Stringifying std::chrono::duration with weird ratios
ok 1170 - pico_second != atto_second for: 1 ps != 1 as
# Stringifying std::chrono::time_point<system_clock>
ok 1171 - now != later for: {iso8601-timestamp} != {iso8601-timestamp}
# Tabs and newlines show in output
not ok 1172 - s1 == s2 for: "if ($b == 10) { 		$a	= 20; }" == "if ($b == 10) { 	$a = 20; } "
# Tag alias can be registered against tag patterns
ok 1173 - what, Contains( "[@zzz]" ) for: "error: tag alias, '[@zzz]' already registered. 	First seen at: file:2 	Redefined at: file:10" contains: "[@zzz]"
# Tag alias can be registered against tag patterns
ok 1174 - what, Contains( "file" ) for: "error: tag alias, '[@zzz]' already registered. 	First seen at: file:2 	Redefined at: file:10" contains: "file"
# Tag alias can be registered against tag patterns
ok 1175 - what, Contains( "2" ) for: "error: tag alias, '[@zzz]' already registered. 	First seen at: file:2 	Redefined at: file:10" contains: "2"
# Tag alias can be registered against tag patterns
ok 1176 - what, Contains( "10" ) for: "error: tag alias, '[@zzz]' already registered. 	First seen at: file:2 	Redefined at: file:10" contains: "10"
# Tag alias can be registered against tag patterns
ok 1177 - registry.add( "[no ampersat]", "", Catch::SourceLineInfo( "file", 3 ) )
# Tag alias can be registered against tag patterns
ok 1178 - registry.add( "[the @ is not at the start]", "", Catch::SourceLineInfo( "file", 3 ) )
# Tag alias can be registered against tag patterns
ok 1179 - registry.add( "@no square bracket at start]", "", Catch::SourceLineInfo( "file", 3 ) )
# Tag alias can be registered against tag patterns
ok 1180 - registry.add( "[@no square bracket at end", "", Catch::SourceLineInfo( "file", 3 ) )
# Template test case method with test types specified inside std::tuple - MyTypes - 0
ok 1181 - Template_Fixture<TestType>::m_a == 1 for: 1 == 1
# Template test case method with test types specified inside std::tuple - MyTypes - 1
ok 1182 - Template_Fixture<TestType>::m_a == 1 for: 1 == 1
# Template test case method with test types specified inside std::tuple - MyTypes - 2
ok 1183 - Template_Fixture<TestType>::m_a == 1 for: 1.0 == 1
# Template test case with test types specified inside non-copyable and non-movable std::tuple - NonCopyableAndNonMovableTypes - 0
ok 1184 - sizeof(TestType) > 0 for: 1 > 0
# Template test case with test types specified inside non-copyable and non-movable std::tuple - NonCopyableAndNonMovableTypes - 1
ok 1185 - sizeof(TestType) > 0 for: 4 > 0
# Template test case with test types specified inside non-default-constructible std::tuple - MyNonDefaultConstructibleTypes - 0
ok 1186 - sizeof(TestType) > 0 for: 1 > 0
# Template test case with test types specified inside non-default-constructible std::tuple - MyNonDefaultConstructibleTypes - 1
ok 1187 - sizeof(TestType) > 0 for: 4 > 0
# Template test case with test types specified inside std::tuple - MyTypes - 0
ok 1188 - sizeof(TestType) > 0 for: 4 > 0
# Template test case with test types specified inside std::tuple - MyTypes - 1
ok 1189 - sizeof(TestType) > 0 for: 1 > 0
# Template test case with test types specified inside std::tuple - MyTypes - 2
ok 1190 - sizeof(TestType) > 0 for: 4 > 0
# TemplateTest: vectors can be sized and resized - float
ok 1191 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - float
ok 1192 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - float
ok 1193 - v.size() == 10 for: 10 == 10
# TemplateTest: vectors can be sized and resized - float
ok 1194 - v.capacity() >= 10 for: 10 >= 10
# TemplateTest: vectors can be sized and resized - float
ok 1195 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - float
ok 1196 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - float
ok 1197 - v.size() == 0 for: 0 == 0
# TemplateTest: vectors can be sized and resized - float
ok 1198 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - float
ok 1199 - v.capacity() == 0 for: 0 == 0
# TemplateTest: vectors can be sized and resized - float
ok 1200 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - float
ok 1201 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - float
ok 1202 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - float
ok 1203 - v.capacity() >= 10 for: 10 >= 10
# TemplateTest: vectors can be sized and resized - float
ok 1204 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - float
ok 1205 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - float
ok 1206 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - float
ok 1207 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - int
ok 1208 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - int
ok 1209 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - int
ok 1210 - v.size() == 10 for: 10 == 10
# TemplateTest: vectors can be sized and resized - int
ok 1211 - v.capacity() >= 10 for: 10 >= 10
# TemplateTest: vectors can be sized and resized - int
ok 1212 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - int
ok 1213 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - int
ok 1214 - v.size() == 0 for: 0 == 0
# TemplateTest: vectors can be sized and resized - int
ok 1215 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - int
ok 1216 - v.capacity() == 0 for: 0 == 0
# TemplateTest: vectors can be sized and resized - int
ok 1217 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - int
ok 1218 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - int
ok 1219 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - int
ok 1220 - v.capacity() >= 10 for: 10 >= 10
# TemplateTest: vectors can be sized and resized - int
ok 1221 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - int
ok 1222 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - int
ok 1223 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - int
ok 1224 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1225 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1226 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1227 - v.size() == 10 for: 10 == 10
# TemplateTest: vectors can be sized and resized - std::string
ok 1228 - v.capacity() >= 10 for: 10 >= 10
# TemplateTest: vectors can be sized and resized - std::string
ok 1229 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1230 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1231 - v.size() == 0 for: 0 == 0
# TemplateTest: vectors can be sized and resized - std::string
ok 1232 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1233 - v.capacity() == 0 for: 0 == 0
# TemplateTest: vectors can be sized and resized - std::string
ok 1234 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1235 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1236 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1237 - v.capacity() >= 10 for: 10 >= 10
# TemplateTest: vectors can be sized and resized - std::string
ok 1238 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1239 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1240 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::string
ok 1241 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1242 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1243 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1244 - v.size() == 10 for: 10 == 10
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1245 - v.capacity() >= 10 for: 10 >= 10
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1246 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1247 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1248 - v.size() == 0 for: 0 == 0
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1249 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1250 - v.capacity() == 0 for: 0 == 0
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1251 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1252 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1253 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1254 - v.capacity() >= 10 for: 10 >= 10
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1255 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1256 - v.capacity() >= 5 for: 5 >= 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1257 - v.size() == 5 for: 5 == 5
# TemplateTest: vectors can be sized and resized - std::tuple<int,float>
ok 1258 - v.capacity() >= 5 for: 5 >= 5
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1259 - v.size() == V for: 6 == 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1260 - v.capacity() >= V for: 6 >= 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1261 - v.size() == 2 * V for: 12 == 12
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1262 - v.capacity() >= 2 * V for: 12 >= 12
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1263 - v.size() == V for: 6 == 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1264 - v.capacity() >= V for: 6 >= 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1265 - v.size() == 0 for: 0 == 0
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1266 - v.capacity() >= V for: 6 >= 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1267 - v.capacity() == 0 for: 0 == 0
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1268 - v.size() == V for: 6 == 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1269 - v.capacity() >= V for: 6 >= 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1270 - v.size() == V for: 6 == 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1271 - v.capacity() >= 2 * V for: 12 >= 12
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1272 - v.size() == V for: 6 == 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1273 - v.capacity() >= V for: 6 >= 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1274 - v.size() == V for: 6 == 6
# TemplateTestSig: vectors can be sized and resized - (std::tuple<int, float>), 6
ok 1275 - v.capacity() >= V for: 6 >= 6
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1276 - v.size() == V for: 4 == 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1277 - v.capacity() >= V for: 4 >= 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1278 - v.size() == 2 * V for: 8 == 8
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1279 - v.capacity() >= 2 * V for: 8 >= 8
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1280 - v.size() == V for: 4 == 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1281 - v.capacity() >= V for: 4 >= 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1282 - v.size() == 0 for: 0 == 0
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1283 - v.capacity() >= V for: 4 >= 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1284 - v.capacity() == 0 for: 0 == 0
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1285 - v.size() == V for: 4 == 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1286 - v.capacity() >= V for: 4 >= 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1287 - v.size() == V for: 4 == 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1288 - v.capacity() >= 2 * V for: 8 >= 8
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1289 - v.size() == V for: 4 == 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1290 - v.capacity() >= V for: 4 >= 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1291 - v.size() == V for: 4 == 4
# TemplateTestSig: vectors can be sized and resized - float,4
ok 1292 - v.capacity() >= V for: 4 >= 4
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1293 - v.size() == V for: 5 == 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1294 - v.capacity() >= V for: 5 >= 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1295 - v.size() == 2 * V for: 10 == 10
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1296 - v.capacity() >= 2 * V for: 10 >= 10
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1297 - v.size() == V for: 5 == 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1298 - v.capacity() >= V for: 5 >= 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1299 - v.size() == 0 for: 0 == 0
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1300 - v.capacity() >= V for: 5 >= 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1301 - v.capacity() == 0 for: 0 == 0
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1302 - v.size() == V for: 5 == 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1303 - v.capacity() >= V for: 5 >= 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1304 - v.size() == V for: 5 == 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1305 - v.capacity() >= 2 * V for: 10 >= 10
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1306 - v.size() == V for: 5 == 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1307 - v.capacity() >= V for: 5 >= 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1308 - v.size() == V for: 5 == 5
# TemplateTestSig: vectors can be sized and resized - int,5
ok 1309 - v.capacity() >= V for: 5 >= 5
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1310 - v.size() == V for: 15 == 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1311 - v.capacity() >= V for: 15 >= 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1312 - v.size() == 2 * V for: 30 == 30
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1313 - v.capacity() >= 2 * V for: 30 >= 30
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1314 - v.size() == V for: 15 == 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1315 - v.capacity() >= V for: 15 >= 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1316 - v.size() == 0 for: 0 == 0
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1317 - v.capacity() >= V for: 15 >= 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1318 - v.capacity() == 0 for: 0 == 0
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1319 - v.size() == V for: 15 == 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1320 - v.capacity() >= V for: 15 >= 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1321 - v.size() == V for: 15 == 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1322 - v.capacity() >= 2 * V for: 30 >= 30
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1323 - v.size() == V for: 15 == 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1324 - v.capacity() >= V for: 15 >= 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1325 - v.size() == V for: 15 == 15
# TemplateTestSig: vectors can be sized and resized - std::string,15
ok 1326 - v.capacity() >= V for: 15 >= 15
# Test case with one argument
ok 1327 - with 1 message: 'no assertions'
# Test enum bit values
ok 1328 - 0x<hex digits> == bit30and31 for: 3221225472 (0x<hex digits>) == 3221225472
# Test with special, characters "in name
ok 1329 -
# The NO_FAIL macro reports a failure but does not fail the test
ok 1330 - 1 == 2  # TODO
# This test 'should' fail but doesn't
ok 1331 - with 1 message: 'oops!'
# Thrown string literals are translated
not ok 1332 - unexpected exception with message: 'For some reason someone is throwing a string literal!'
# Tracker
ok 1333 - testCase.isOpen() for: true
# Tracker
ok 1334 - s1.isOpen() for: true
# Tracker
ok 1335 - s1.isSuccessfullyCompleted() for: true
# Tracker
ok 1336 - testCase.isComplete() == false for: false == false
# Tracker
ok 1337 - ctx.completedCycle() for: true
# Tracker
ok 1338 - testCase.isSuccessfullyCompleted() for: true
# Tracker
ok 1339 - testCase.isOpen() for: true
# Tracker
ok 1340 - s1.isOpen() for: true
# Tracker
ok 1341 - s1.isComplete() for: true
# Tracker
ok 1342 - s1.isSuccessfullyCompleted() == false for: false == false
# Tracker
ok 1343 - testCase.isComplete() == false for: false == false
# Tracker
ok 1344 - ctx.completedCycle() for: true
# Tracker
ok 1345 - testCase.isSuccessfullyCompleted() == false for: false == false
# Tracker
ok 1346 - testCase2.isOpen() for: true
# Tracker
ok 1347 - s1b.isOpen() == false for: false == false
# Tracker
ok 1348 - ctx.completedCycle() for: true
# Tracker
ok 1349 - testCase.isComplete() for: true
# Tracker
ok 1350 - testCase.isSuccessfullyCompleted() for: true
# Tracker
ok 1351 - testCase.isOpen() for: true
# Tracker
ok 1352 - s1.isOpen() for: true
# Tracker
ok 1353 - s1.isComplete() for: true
# Tracker
ok 1354 - s1.isSuccessfullyCompleted() == false for: false == false
# Tracker
ok 1355 - testCase.isComplete() == false for: false == false
# Tracker
ok 1356 - ctx.completedCycle() for: true
# Tracker
ok 1357 - testCase.isSuccessfullyCompleted() == false for: false == false
# Tracker
ok 1358 - testCase2.isOpen() for: true
# Tracker
ok 1359 - s1b.isOpen() == false for: false == false
# Tracker
ok 1360 - s2.isOpen() for: true
# Tracker
ok 1361 - ctx.completedCycle() for: true
# Tracker
ok 1362 - testCase.isComplete() for: true
# Tracker
ok 1363 - testCase.isSuccessfullyCompleted() for: true
# Tracker
ok 1364 - testCase.isOpen() for: true
# Tracker
ok 1365 - s1.isOpen() for: true
# Tracker
ok 1366 - s2.isOpen() == false for: false == false
# Tracker
ok 1367 - testCase.isComplete() == false for: false == false
# Tracker
ok 1368 - testCase2.isOpen() for: true
# Tracker
ok 1369 - s1b.isOpen() == false for: false == false
# Tracker
ok 1370 - s2b.isOpen() for: true
# Tracker
ok 1371 - ctx.completedCycle() == false for: false == false
# Tracker
ok 1372 - ctx.completedCycle() for: true
# Tracker
ok 1373 - s2b.isSuccessfullyCompleted() for: true
# Tracker
ok 1374 - testCase2.isComplete() == false for: false == false
# Tracker
ok 1375 - testCase2.isSuccessfullyCompleted() for: true
# Tracker
ok 1376 - testCase.isOpen() for: true
# Tracker
ok 1377 - s1.isOpen() for: true
# Tracker
ok 1378 - s2.isOpen() == false for: false == false
# Tracker
ok 1379 - testCase.isComplete() == false for: false == false
# Tracker
ok 1380 - testCase2.isOpen() for: true
# Tracker
ok 1381 - s1b.isOpen() == false for: false == false
# Tracker
ok 1382 - s2b.isOpen() for: true
# Tracker
ok 1383 - ctx.completedCycle() == false for: false == false
# Tracker
ok 1384 - ctx.completedCycle() for: true
# Tracker
ok 1385 - s2b.isComplete() for: true
# Tracker
ok 1386 - s2b.isSuccessfullyCompleted() == false for: false == false
# Tracker
ok 1387 - testCase2.isSuccessfullyCompleted() == false for: false == false
# Tracker
ok 1388 - testCase3.isOpen() for: true
# Tracker
ok 1389 - s1c.isOpen() == false for: false == false
# Tracker
ok 1390 - s2c.isOpen() == false for: false == false
# Tracker
ok 1391 - testCase3.isSuccessfullyCompleted() for: true
# Tracker
ok 1392 - testCase.isOpen() for: true
# Tracker
ok 1393 - s1.isOpen() for: true
# Tracker
ok 1394 - s2.isOpen() for: true
# Tracker
ok 1395 - s2.isComplete() for: true
# Tracker
ok 1396 - s1.isComplete() == false for: false == false
# Tracker
ok 1397 - s1.isComplete() for: true
# Tracker
ok 1398 - testCase.isComplete() == false for: false == false
# Tracker
ok 1399 - testCase.isComplete() for: true
# Trim strings
ok 1400 - trim(std::string(no_whitespace)) == no_whitespace for: "There is no extra whitespace here" == "There is no extra whitespace here"
# Trim strings
ok 1401 - trim(std::string(leading_whitespace)) == no_whitespace for: "There is no extra whitespace here" == "There is no extra whitespace here"
# Trim strings
ok 1402 - trim(std::string(trailing_whitespace)) == no_whitespace for: "There is no extra whitespace here" == "There is no extra whitespace here"
# Trim strings
ok 1403 - trim(std::string(whitespace_at_both_ends)) == no_whitespace for: "There is no extra whitespace here" == "There is no extra whitespace here"
# Trim strings
ok 1404 - trim(StringRef(no_whitespace)) == StringRef(no_whitespace) for: There is no extra whitespace here == There is no extra whitespace here
# Trim strings
ok 1405 - trim(StringRef(leading_whitespace)) == StringRef(no_whitespace) for: There is no extra whitespace here == There is no extra whitespace here
# Trim strings
ok 1406 - trim(StringRef(trailing_whitespace)) == StringRef(no_whitespace) for: There is no extra whitespace here == There is no extra whitespace here
# Trim strings
ok 1407 - trim(StringRef(whitespace_at_both_ends)) == StringRef(no_whitespace) for: There is no extra whitespace here == There is no extra whitespace here
# Unexpected exceptions can be translated
not ok 1408 - unexpected exception with message: '3.14'
# Use a custom approx
ok 1409 - d == approx( 1.23 ) for: 1.23 == Approx( 1.23 )
# Use a custom approx
ok 1410 - d == approx( 1.22 ) for: 1.23 == Approx( 1.22 )
# Use a custom approx
ok 1411 - d == approx( 1.24 ) for: 1.23 == Approx( 1.24 )
# Use a custom approx
ok 1412 - d != approx( 1.25 ) for: 1.23 != Approx( 1.25 )
# Use a custom approx
ok 1413 - approx( d ) == 1.23 for: Approx( 1.23 ) == 1.23
# Use a custom approx
ok 1414 - approx( d ) == 1.22 for: Approx( 1.23 ) == 1.22
# Use a custom approx
ok 1415 - approx( d ) == 1.24 for: Approx( 1.23 ) == 1.24
# Use a custom approx
ok 1416 - approx( d ) != 1.25 for: Approx( 1.23 ) != 1.25
# Variadic macros
ok 1417 - with 1 message: 'no assertions'
# Vector Approx matcher
ok 1418 - empty, Approx(empty) for: {  } is approx: {  }
# Vector Approx matcher
ok 1419 - v1, Approx(v1) for: { 1.0, 2.0, 3.0 } is approx: { 1.0, 2.0, 3.0 }
# Vector Approx matcher
ok 1420 - v1, !Approx(temp) for: { 1.0, 2.0, 3.0 } not is approx: { 1.0, 2.0, 3.0, 4.0 }
# Vector Approx matcher
ok 1421 - v1, !Approx(v2) for: { 1.0, 2.0, 3.0 } not is approx: { 1.5, 2.5, 3.5 }
# Vector Approx matcher
ok 1422 - v1, Approx(v2).margin(0.5) for: { 1.0, 2.0, 3.0 } is approx: { 1.5, 2.5, 3.5 }
# Vector Approx matcher
ok 1423 - v1, Approx(v2).epsilon(0.5) for: { 1.0, 2.0, 3.0 } is approx: { 1.5, 2.5, 3.5 }
# Vector Approx matcher
ok 1424 - v1, Approx(v2).epsilon(0.1).scale(500) for: { 1.0, 2.0, 3.0 } is approx: { 1.5, 2.5, 3.5 }
# Vector Approx matcher -- failing
not ok 1425 - empty, Approx(t1) for: {  } is approx: { 1.0, 2.0 }
# Vector Approx matcher -- failing
not ok 1426 - v1, Approx(v2) for: { 2.0, 4.0, 6.0 } is approx: { 1.0, 3.0, 5.0 }
# Vector matchers
ok 1427 - v, VectorContains(1) for: { 1, 2, 3 } Contains: 1
# Vector matchers
ok 1428 - v, VectorContains(2) for: { 1, 2, 3 } Contains: 2
# Vector matchers
ok 1429 - v, Contains(v2) for: { 1, 2, 3 } Contains: { 1, 2 }
# Vector matchers
ok 1430 - v, Contains(v2) for: { 1, 2, 3 } Contains: { 1, 2, 3 }
# Vector matchers
ok 1431 - v, Contains(empty) for: { 1, 2, 3 } Contains: {  }
# Vector matchers
ok 1432 - empty, Contains(empty) for: {  } Contains: {  }
# Vector matchers
ok 1433 - v, VectorContains(1) && VectorContains(2) for: { 1, 2, 3 } ( Contains: 1 and Contains: 2 )
# Vector matchers
ok 1434 - v, Equals(v) for: { 1, 2, 3 } Equals: { 1, 2, 3 }
# Vector matchers
ok 1435 - empty, Equals(empty) for: {  } Equals: {  }
# Vector matchers
ok 1436 - v, Equals(v2) for: { 1, 2, 3 } Equals: { 1, 2, 3 }
# Vector matchers
ok 1437 - v, UnorderedEquals(v) for: { 1, 2, 3 } UnorderedEquals: { 1, 2, 3 }
# Vector matchers
ok 1438 - empty, UnorderedEquals(empty) for: {  } UnorderedEquals: {  }
# Vector matchers
ok 1439 - permuted, UnorderedEquals(v) for: { 1, 3, 2 } UnorderedEquals: { 1, 2, 3 }
# Vector matchers
ok 1440 - permuted, UnorderedEquals(v) for: { 2, 3, 1 } UnorderedEquals: { 1, 2, 3 }
# Vector matchers that fail
not ok 1441 - v, VectorContains(-1) for: { 1, 2, 3 } Contains: -1
# Vector matchers that fail
not ok 1442 - empty, VectorContains(1) for: {  } Contains: 1
# Vector matchers that fail
not ok 1443 - empty, Contains(v) for: {  } Contains: { 1, 2, 3 }
# Vector matchers that fail
not ok 1444 - v, Contains(v2) for: { 1, 2, 3 } Contains: { 1, 2, 4 }
# Vector matchers that fail
not ok 1445 - v, Equals(v2) for: { 1, 2, 3 } Equals: { 1, 2 }
# Vector matchers that fail
not ok 1446 - v2, Equals(v) for: { 1, 2 } Equals: { 1, 2, 3 }
# Vector matchers that fail
not ok 1447 - empty, Equals(v) for: {  } Equals: { 1, 2, 3 }
# Vector matchers that fail
not ok 1448 - v, Equals(empty) for: { 1, 2, 3 } Equals: {  }
# Vector matchers that fail
not ok 1449 - v, UnorderedEquals(empty) for: { 1, 2, 3 } UnorderedEquals: {  }
# Vector matchers that fail
not ok 1450 - empty, UnorderedEquals(v) for: {  } UnorderedEquals: { 1, 2, 3 }
# Vector matchers that fail
not ok 1451 - permuted, UnorderedEquals(v) for: { 1, 3 } UnorderedEquals: { 1, 2, 3 }
# Vector matchers that fail
not ok 1452 - permuted, UnorderedEquals(v) for: { 3, 1 } UnorderedEquals: { 1, 2, 3 }
# When checked exceptions are thrown they can be expected or unexpected
ok 1453 - thisThrows(), std::domain_error
# When checked exceptions are thrown they can be expected or unexpected
ok 1454 - thisDoesntThrow()
# When checked exceptions are thrown they can be expected or unexpected
ok 1455 - thisThrows()
# When unchecked exceptions are thrown directly they are always failures
not ok 1456 - unexpected exception with message: 'unexpected exception'
# When unchecked exceptions are thrown during a CHECK the test should continue
not ok 1457 - unexpected exception with message: 'expected exception'; expression was: thisThrows() == 0
# When unchecked exceptions are thrown during a REQUIRE the test should abort fail
not ok 1458 - unexpected exception with message: 'expected exception'; expression was: thisThrows() == 0
# When unchecked exceptions are thrown from functions they are always failures
not ok 1459 - unexpected exception with message: 'expected exception'; expression was: thisThrows() == 0
# When unchecked exceptions are thrown from sections they are always failures
not ok 1460 - unexpected exception with message: 'unexpected exception'
# Where the LHS is not a simple value
warning 1461 - 'Uncomment the code in this test to check that it gives a sensible compiler error'
# Where there is more to the expression after the RHS
warning 1462 - 'Uncomment the code in this test to check that it gives a sensible compiler error'
# X/level/0/a
ok 1463 -
# X/level/0/b
ok 1464 -
# X/level/1/a
ok 1465 -
# X/level/1/b
ok 1466 -
# XmlEncode
ok 1467 - encode( "normal string" ) == "normal string" for: "normal string" == "normal string"
# XmlEncode
ok 1468 - encode( "" ) == "" for: "" == ""
# XmlEncode
ok 1469 - encode( "smith & jones" ) == "smith &amp; jones" for: "smith &amp; jones" == "smith &amp; jones"
# XmlEncode
ok 1470 - encode( "smith < jones" ) == "smith &lt; jones" for: "smith &lt; jones" == "smith &lt; jones"
# XmlEncode
ok 1471 - encode( "smith > jones" ) == "smith > jones" for: "smith > jones" == "smith > jones"
# XmlEncode
ok 1472 - encode( "smith ]]> jones" ) == "smith ]]&gt; jones" for: "smith ]]&gt; jones" == "smith ]]&gt; jones"
# XmlEncode
ok 1473 - encode( stringWithQuotes ) == stringWithQuotes for: "don't "quote" me on that" == "don't "quote" me on that"
# XmlEncode
ok 1474 - encode( stringWithQuotes, Catch::XmlEncode::ForAttributes ) == "don't &quot;quote&quot; me on that" for: "don't &quot;quote&quot; me on that" == "don't &quot;quote&quot; me on that"
# XmlEncode
ok 1475 - encode( "[\x01]" ) == "[\\x01]" for: "[\x01]" == "[\x01]"
# XmlEncode
ok 1476 - encode( "[\x7F]" ) == "[\\x7F]" for: "[\x7F]" == "[\x7F]"
# array<int, N> -> toString
ok 1477 - Catch::Detail::stringify( empty ) == "{  }" for: "{  }" == "{  }"
# array<int, N> -> toString
ok 1478 - Catch::Detail::stringify( oneValue ) == "{ 42 }" for: "{ 42 }" == "{ 42 }"
# array<int, N> -> toString
ok 1479 - Catch::Detail::stringify( twoValues ) == "{ 42, 250 }" for: "{ 42, 250 }" == "{ 42, 250 }"
# atomic if
ok 1480 - x == 0 for: 0 == 0
# boolean member
ok 1481 - obj.prop != 0 for: 0x<hex digits> != 0
# checkedElse
ok 1482 - flag for: true
# checkedElse
ok 1483 - testCheckedElse( true ) for: true
# checkedElse, failing
not ok 1484 - flag for: false
# checkedElse, failing
not ok 1485 - testCheckedElse( false ) for: false
# checkedIf
ok 1486 - flag for: true
# checkedIf
ok 1487 - testCheckedIf( true ) for: true
# checkedIf, failing
not ok 1488 - flag for: false
# checkedIf, failing
not ok 1489 - testCheckedIf( false ) for: false
# comparisons between const int variables
ok 1490 - unsigned_char_var == 1 for: 1 == 1
# comparisons between const int variables
ok 1491 - unsigned_short_var == 1 for: 1 == 1
# comparisons between const int variables
ok 1492 - unsigned_int_var == 1 for: 1 == 1
# comparisons between const int variables
ok 1493 - unsigned_long_var == 1 for: 1 == 1
# comparisons between int variables
ok 1494 - long_var == unsigned_char_var for: 1 == 1
# comparisons between int variables
ok 1495 - long_var == unsigned_short_var for: 1 == 1
# comparisons between int variables
ok 1496 - long_var == unsigned_int_var for: 1 == 1
# comparisons between int variables
ok 1497 - long_var == unsigned_long_var for: 1 == 1
# even more nested SECTION tests
ok 1498 -
# even more nested SECTION tests
ok 1499 -
# even more nested SECTION tests
ok 1500 -
loose text artifact
# just failure
not ok 1501 - explicitly with 1 message: 'Previous info should not be seen'
# just failure after unscoped info
not ok 1502 - explicitly with 1 message: 'previous unscoped info SHOULD not be seen'
# long long
ok 1503 - l == std::numeric_limits<long long>::max() for: 9223372036854775807 (0x<hex digits>) == 9223372036854775807 (0x<hex digits>)
# looped SECTION tests
not ok 1504 - b > a for: 0 > 1
# looped SECTION tests
not ok 1505 - b > a for: 1 > 1
# looped SECTION tests
ok 1506 - b > a for: 2 > 1
# looped SECTION tests
ok 1507 - b > a for: 3 > 1
# looped SECTION tests
ok 1508 - b > a for: 4 > 1
# looped SECTION tests
ok 1509 - b > a for: 5 > 1
# looped SECTION tests
ok 1510 - b > a for: 6 > 1
# looped SECTION tests
ok 1511 - b > a for: 7 > 1
# looped SECTION tests
ok 1512 - b > a for: 8 > 1
# looped SECTION tests
ok 1513 - b > a for: 9 > 1
# looped tests
not ok 1514 - ( fib[i] % 2 ) == 0 for: 1 == 0 with 1 message: 'Testing if fib[0] (1) is even'
# looped tests
not ok 1515 - ( fib[i] % 2 ) == 0 for: 1 == 0 with 1 message: 'Testing if fib[1] (1) is even'
# looped tests
ok 1516 - ( fib[i] % 2 ) == 0 for: 0 == 0 with 1 message: 'Testing if fib[2] (2) is even'
# looped tests
not ok 1517 - ( fib[i] % 2 ) == 0 for: 1 == 0 with 1 message: 'Testing if fib[3] (3) is even'
# looped tests
not ok 1518 - ( fib[i] % 2 ) == 0 for: 1 == 0 with 1 message: 'Testing if fib[4] (5) is even'
# looped tests
ok 1519 - ( fib[i] % 2 ) == 0 for: 0 == 0 with 1 message: 'Testing if fib[5] (8) is even'
# looped tests
not ok 1520 - ( fib[i] % 2 ) == 0 for: 1 == 0 with 1 message: 'Testing if fib[6] (13) is even'
# looped tests
not ok 1521 - ( fib[i] % 2 ) == 0 for: 1 == 0 with 1 message: 'Testing if fib[7] (21) is even'
# mix info, unscoped info and warning
warning 1522 - 'info' with 2 messages: 'unscoped info' and 'and warn may mix'
# mix info, unscoped info and warning
warning 1523 - 'info' with 2 messages: 'unscoped info' and 'they are not cleared after warnings'
# more nested SECTION tests
not ok 1524 - a == b for: 1 == 2
# more nested SECTION tests
ok 1525 - a != b for: 1 != 2
# more nested SECTION tests
ok 1526 - a < b for: 1 < 2
# nested SECTION tests
ok 1527 - a != b for: 1 != 2
# nested SECTION tests
ok 1528 - b != a for: 2 != 1
# nested SECTION tests
ok 1529 - a != b for: 1 != 2
# non streamable - with conv. op
ok 1530 - s == "7" for: "7" == "7"
# non-copyable objects
ok 1531 - ti == typeid(int) for: {?} == {?}
# not allowed
ok 1532 -
# not prints unscoped info from previous failures
ok 1533 - true with 1 message: 'this MAY be seen only for the FIRST assertion IF info is printed for passing assertions'
# not prints unscoped info from previous failures
ok 1534 - true with 1 message: 'this MAY be seen only for the SECOND assertion IF info is printed for passing assertions'
# not prints unscoped info from previous failures
not ok 1535 - false with 1 message: 'this SHOULD be seen'
# null strings
ok 1536 - makeString( false ) != static_cast<char*>(0) for: "valid string" != {null string}
# null strings
ok 1537 - makeString( true ) == static_cast<char*>(0) for: {null string} == {null string}
# null_ptr
ok 1538 - ptr.get() == 0 for: 0 == 0
# pair<pair<int,const char *,pair<std::string,int> > -> toString
ok 1539 - ::Catch::Detail::stringify( pair ) == "{ { 42, \"Arthur\" }, { \"Ford\", 24 } }" for: "{ { 42, "Arthur" }, { "Ford", 24 } }" == "{ { 42, "Arthur" }, { "Ford", 24 } }"
# parseEnums
ok 1540 - parseEnums( "" ), Equals( std::vector<Catch::StringRef>{} ) for: {  } Equals: {  }
# parseEnums
ok 1541 - parseEnums( "ClassName::EnumName::Value1" ), Equals(std::vector<Catch::StringRef>{"Value1"} ) for: { Value1 } Equals: { Value1 }
# parseEnums
ok 1542 - parseEnums( "Value1" ), Equals( std::vector<Catch::StringRef>{"Value1"} ) for: { Value1 } Equals: { Value1 }
# parseEnums
ok 1543 - parseEnums( "EnumName::Value1" ), Equals(std::vector<Catch::StringRef>{"Value1"} ) for: { Value1 } Equals: { Value1 }
# parseEnums
ok 1544 - parseEnums( "ClassName::EnumName::Value1, ClassName::EnumName::Value2" ), Equals( std::vector<Catch::StringRef>{"Value1", "Value2"} ) for: { Value1, Value2 } Equals: { Value1, Value2 }
# parseEnums
ok 1545 - parseEnums( "ClassName::EnumName::Value1, ClassName::EnumName::Value2, ClassName::EnumName::Value3" ), Equals( std::vector<Catch::StringRef>{"Value1", "Value2", "Value3"} ) for: { Value1, Value2, Value3 } Equals: { Value1, Value2, Value3 }
# parseEnums
ok 1546 - parseEnums( "ClassName::EnumName::Value1,ClassName::EnumName::Value2 , ClassName::EnumName::Value3" ), Equals( std::vector<Catch::StringRef>{"Value1", "Value2", "Value3"} ) for: { Value1, Value2, Value3 } Equals: { Value1, Value2, Value3 }
# pointer to class
ok 1547 - p == 0 for: 0 == 0
# print unscoped info if passing unscoped info is printed
ok 1548 - true with 1 message: 'this MAY be seen IF info is printed for passing assertions'
# prints unscoped info on failure
not ok 1549 - false with 2 messages: 'this SHOULD be seen' and 'this SHOULD also be seen'
# prints unscoped info only for the first assertion
not ok 1550 - false with 1 message: 'this SHOULD be seen only ONCE'
# prints unscoped info only for the first assertion
ok 1551 - true
# prints unscoped info only for the first assertion
ok 1552 - true with 1 message: 'this MAY also be seen only ONCE IF info is printed for passing assertions'
# prints unscoped info only for the first assertion
ok 1553 - true
# random SECTION tests
ok 1554 - a != b for: 1 != 2
# random SECTION tests
ok 1555 - b != a for: 2 != 1
# random SECTION tests
ok 1556 - a != b for: 1 != 2
# replaceInPlace
ok 1557 - Catch::replaceInPlace(letters, "b", "z") for: true
# replaceInPlace
ok 1558 - letters == "azcdefcg" for: "azcdefcg" == "azcdefcg"
# replaceInPlace
ok 1559 - Catch::replaceInPlace(letters, "c", "z") for: true
# replaceInPlace
ok 1560 - letters == "abzdefzg" for: "abzdefzg" == "abzdefzg"
# replaceInPlace
ok 1561 - Catch::replaceInPlace(letters, "a", "z") for: true
# replaceInPlace
ok 1562 - letters == "zbcdefcg" for: "zbcdefcg" == "zbcdefcg"
# replaceInPlace
ok 1563 - Catch::replaceInPlace(letters, "g", "z") for: true
# replaceInPlace
ok 1564 - letters == "abcdefcz" for: "abcdefcz" == "abcdefcz"
# replaceInPlace
ok 1565 - Catch::replaceInPlace(letters, letters, "replaced") for: true
# replaceInPlace
ok 1566 - letters == "replaced" for: "replaced" == "replaced"
# replaceInPlace
ok 1567 - !(Catch::replaceInPlace(letters, "x", "z")) for: !false
# replaceInPlace
ok 1568 - letters == letters for: "abcdefcg" == "abcdefcg"
# replaceInPlace
ok 1569 - Catch::replaceInPlace(s, "'", "|'") for: true
# replaceInPlace
ok 1570 - s == "didn|'t" for: "didn|'t" == "didn|'t"
# send a single char to INFO
not ok 1571 - false with 1 message: '3'
# sends information to INFO
not ok 1572 - false with 2 messages: 'hi' and 'i := 7'
# shortened hide tags are split apart
ok 1573 - tags, Catch::VectorContains("magic-tag"_catch_sr) && Catch::VectorContains("."_catch_sr) for: { ., magic-tag } ( Contains: magic-tag and Contains: . )
# splitString
ok 1574 - splitStringRef("", ','), Equals(std::vector<StringRef>()) for: {  } Equals: {  }
# splitString
ok 1575 - splitStringRef("abc", ','), Equals(std::vector<StringRef>{"abc"}) for: { abc } Equals: { abc }
# splitString
ok 1576 - splitStringRef("abc,def", ','), Equals(std::vector<StringRef>{"abc", "def"}) for: { abc, def } Equals: { abc, def }
# stacks unscoped info in loops
not ok 1577 - false with 4 messages: 'Count 1 to 3...' and '1' and '2' and '3'
# stacks unscoped info in loops
not ok 1578 - false with 4 messages: 'Count 4 to 6...' and '4' and '5' and '6'
# std::map is convertible string
ok 1579 - Catch::Detail::stringify( emptyMap ) == "{  }" for: "{  }" == "{  }"
# std::map is convertible string
ok 1580 - Catch::Detail::stringify( map ) == "{ { \"one\", 1 } }" for: "{ { "one", 1 } }" == "{ { "one", 1 } }"
# std::map is convertible string
ok 1581 - Catch::Detail::stringify( map ) == "{ { \"abc\", 1 }, { \"def\", 2 }, { \"ghi\", 3 } }" for: "{ { "abc", 1 }, { "def", 2 }, { "ghi", 3 } }" == "{ { "abc", 1 }, { "def", 2 }, { "ghi", 3 } }"
# std::pair<int,const std::string> -> toString
ok 1582 - ::Catch::Detail::stringify(value) == "{ 34, \"xyzzy\" }" for: "{ 34, "xyzzy" }" == "{ 34, "xyzzy" }"
# std::pair<int,std::string> -> toString
ok 1583 - ::Catch::Detail::stringify( value ) == "{ 34, \"xyzzy\" }" for: "{ 34, "xyzzy" }" == "{ 34, "xyzzy" }"
# std::set is convertible string
ok 1584 - Catch::Detail::stringify( emptySet ) == "{  }" for: "{  }" == "{  }"
# std::set is convertible string
ok 1585 - Catch::Detail::stringify( set ) == "{ \"one\" }" for: "{ "one" }" == "{ "one" }"
# std::set is convertible string
ok 1586 - Catch::Detail::stringify( set ) == "{ \"abc\", \"def\", \"ghi\" }" for: "{ "abc", "def", "ghi" }" == "{ "abc", "def", "ghi" }"
# std::vector<std::pair<std::string,int> > -> toString
ok 1587 - ::Catch::Detail::stringify( pr ) == "{ { \"green\", 55 } }" for: "{ { "green", 55 } }" == "{ { "green", 55 } }"
# string literals of different sizes can be compared
not ok 1588 - std::string( "first" ) == "second" for: "first" == "second"
# stringify ranges
ok 1589 - ::Catch::Detail::stringify(streamable_range{}) == "op<<(streamable_range)" for: "op<<(streamable_range)" == "op<<(streamable_range)"
# stringify ranges
ok 1590 - ::Catch::Detail::stringify(stringmaker_range{}) == "stringmaker(streamable_range)" for: "stringmaker(streamable_range)" == "stringmaker(streamable_range)"
# stringify ranges
ok 1591 - ::Catch::Detail::stringify(just_range{}) == "{ 1, 2, 3, 4 }" for: "{ 1, 2, 3, 4 }" == "{ 1, 2, 3, 4 }"
# stringify ranges
ok 1592 - ::Catch::Detail::stringify(disabled_range{}) == "{?}" for: "{?}" == "{?}"
# stringify( has_maker )
ok 1593 - ::Catch::Detail::stringify( item ) == "StringMaker<has_maker>" for: "StringMaker<has_maker>" == "StringMaker<has_maker>"
# stringify( has_maker_and_operator )
ok 1594 - ::Catch::Detail::stringify( item ) == "StringMaker<has_maker_and_operator>" for: "StringMaker<has_maker_and_operator>" == "StringMaker<has_maker_and_operator>"
# stringify( has_neither )
ok 1595 - ::Catch::Detail::stringify(item) == "{?}" for: "{?}" == "{?}"
# stringify( has_operator )
ok 1596 - ::Catch::Detail::stringify( item ) == "operator<<( has_operator )" for: "operator<<( has_operator )" == "operator<<( has_operator )"
# stringify( has_template_operator )
ok 1597 - ::Catch::Detail::stringify( item ) == "operator<<( has_template_operator )" for: "operator<<( has_template_operator )" == "operator<<( has_template_operator )"
# stringify( vectors<has_maker> )
ok 1598 - ::Catch::Detail::stringify( v ) == "{ StringMaker<has_maker> }" for: "{ StringMaker<has_maker> }" == "{ StringMaker<has_maker> }"
# stringify( vectors<has_maker_and_operator> )
ok 1599 - ::Catch::Detail::stringify( v ) == "{ StringMaker<has_maker_and_operator> }" for: "{ StringMaker<has_maker_and_operator> }" == "{ StringMaker<has_maker_and_operator> }"
# stringify( vectors<has_operator> )
ok 1600 - ::Catch::Detail::stringify( v ) == "{ operator<<( has_operator ) }" for: "{ operator<<( has_operator ) }" == "{ operator<<( has_operator ) }"
# strlen3
ok 1601 - data.str.size() == data.len for: 3 == 3
# strlen3
ok 1602 - data.str.size() == data.len for: 3 == 3
# strlen3
ok 1603 - data.str.size() == data.len for: 5 == 5
# strlen3
ok 1604 - data.str.size() == data.len for: 4 == 4
# tables
ok 1605 - strlen(std::get<0>(data)) == static_cast<size_t>(std::get<1>(data)) for: 5 == 5
# tables
ok 1606 - strlen(std::get<0>(data)) == static_cast<size_t>(std::get<1>(data)) for: 6 == 6
# tables
ok 1607 - strlen(std::get<0>(data)) == static_cast<size_t>(std::get<1>(data)) for: 5 == 5
# tables
ok 1608 - strlen(std::get<0>(data)) == static_cast<size_t>(std::get<1>(data)) for: 6 == 6
# thrown std::strings are translated
not ok 1609 - unexpected exception with message: 'Why would you throw a std::string?'
# toString on const wchar_t const pointer returns the string contents
ok 1610 - result == "\"wide load\"" for: ""wide load"" == ""wide load""
# toString on const wchar_t pointer returns the string contents
ok 1611 - result == "\"wide load\"" for: ""wide load"" == ""wide load""
# toString on wchar_t const pointer returns the string contents
ok 1612 - result == "\"wide load\"" for: ""wide load"" == ""wide load""
# toString on wchar_t returns the string contents
ok 1613 - result == "\"wide load\"" for: ""wide load"" == ""wide load""
# toString(enum class w/operator<<)
ok 1614 - ::Catch::Detail::stringify(e0) == "E2/V0" for: "E2/V0" == "E2/V0"
# toString(enum class w/operator<<)
ok 1615 - ::Catch::Detail::stringify(e1) == "E2/V1" for: "E2/V1" == "E2/V1"
# toString(enum class w/operator<<)
ok 1616 - ::Catch::Detail::stringify(e3) == "Unknown enum value 10" for: "Unknown enum value 10" == "Unknown enum value 10"
# toString(enum class)
ok 1617 - ::Catch::Detail::stringify(e0) == "0" for: "0" == "0"
# toString(enum class)
ok 1618 - ::Catch::Detail::stringify(e1) == "1" for: "1" == "1"
# toString(enum w/operator<<)
ok 1619 - ::Catch::Detail::stringify(e0) == "E2{0}" for: "E2{0}" == "E2{0}"
# toString(enum w/operator<<)
ok 1620 - ::Catch::Detail::stringify(e1) == "E2{1}" for: "E2{1}" == "E2{1}"
# toString(enum)
ok 1621 - ::Catch::Detail::stringify(e0) == "0" for: "0" == "0"
# toString(enum)
ok 1622 - ::Catch::Detail::stringify(e1) == "1" for: "1" == "1"
# tuple<>
ok 1623 - "{ }" == ::Catch::Detail::stringify(type{}) for: "{ }" == "{ }"
# tuple<>
ok 1624 - "{ }" == ::Catch::Detail::stringify(value) for: "{ }" == "{ }"
# tuple<float,int>
ok 1625 - "1.2f" == ::Catch::Detail::stringify(float(1.2)) for: "1.2f" == "1.2f"
# tuple<float,int>
ok 1626 - "{ 1.2f, 0 }" == ::Catch::Detail::stringify(type{1.2f,0}) for: "{ 1.2f, 0 }" == "{ 1.2f, 0 }"
# tuple<int>
ok 1627 - "{ 0 }" == ::Catch::Detail::stringify(type{0}) for: "{ 0 }" == "{ 0 }"
# tuple<0,int,const char *>
ok 1628 - "{ 0, 42, \"Catch me\" }" == ::Catch::Detail::stringify(value) for: "{ 0, 42, "Catch me" }" == "{ 0, 42, "Catch me" }"
# tuple<string,string>
ok 1629 - "{ \"hello\", \"world\" }" == ::Catch::Detail::stringify(type{"hello","world"}) for: "{ "hello", "world" }" == "{ "hello", "world" }"
# tuple<tuple<int>,tuple<>,float>
ok 1630 - "{ { 42 }, { }, 1.2f }" == ::Catch::Detail::stringify(value) for: "{ { 42 }, { }, 1.2f }" == "{ { 42 }, { }, 1.2f }"
# vec<vec<string,alloc>> -> toString
ok 1631 - ::Catch::Detail::stringify(v) == "{  }" for: "{  }" == "{  }"
# vec<vec<string,alloc>> -> toString
ok 1632 - ::Catch::Detail::stringify(v) == "{ { \"hello\" }, { \"world\" } }" for: "{ { "hello" }, { "world" } }" == "{ { "hello" }, { "world" } }"
# vector<bool> -> toString
ok 1633 - ::Catch::Detail::stringify(bools) == "{  }" for: "{  }" == "{  }"
# vector<bool> -> toString
ok 1634 - ::Catch::Detail::stringify(bools) == "{ true }" for: "{ true }" == "{ true }"
# vector<bool> -> toString
ok 1635 - ::Catch::Detail::stringify(bools) == "{ true, false }" for: "{ true, false }" == "{ true, false }"
# vector<int,allocator> -> toString
ok 1636 - ::Catch::Detail::stringify(vv) == "{  }" for: "{  }" == "{  }"
# vector<int,allocator> -> toString
ok 1637 - ::Catch::Detail::stringify(vv) == "{ 42 }" for: "{ 42 }" == "{ 42 }"
# vector<int,allocator> -> toString
ok 1638 - ::Catch::Detail::stringify(vv) == "{ 42, 250 }" for: "{ 42, 250 }" == "{ 42, 250 }"
# vector<int> -> toString
ok 1639 - ::Catch::Detail::stringify(vv) == "{  }" for: "{  }" == "{  }"
# vector<int> -> toString
ok 1640 - ::Catch::Detail::stringify(vv) == "{ 42 }" for: "{ 42 }" == "{ 42 }"
# vector<int> -> toString
ok 1641 - ::Catch::Detail::stringify(vv) == "{ 42, 250 }" for: "{ 42, 250 }" == "{ 42, 250 }"
# vector<string> -> toString
ok 1642 - ::Catch::Detail::stringify(vv) == "{  }" for: "{  }" == "{  }"
# vector<string> -> toString
ok 1643 - ::Catch::Detail::stringify(vv) == "{ \"hello\" }" for: "{ "hello" }" == "{ "hello" }"
# vector<string> -> toString
ok 1644 - ::Catch::Detail::stringify(vv) == "{ \"hello\", \"world\" }" for: "{ "hello", "world" }" == "{ "hello", "world" }"
# vectors can be sized and resized
ok 1645 - v.size() == 5 for: 5 == 5
# vectors can be sized and resized
ok 1646 - v.capacity() >= 5 for: 5 >= 5
# vectors can be sized and resized
ok 1647 - v.size() == 10 for: 10 == 10
# vectors can be sized and resized
ok 1648 - v.capacity() >= 10 for: 10 >= 10
# vectors can be sized and resized
ok 1649 - v.size() == 5 for: 5 == 5
# vectors can be sized and resized
ok 1650 - v.capacity() >= 5 for: 5 >= 5
# vectors can be sized and resized
ok 1651 - v.size() == 0 for: 0 == 0
# vectors can be sized and resized
ok 1652 - v.capacity() >= 5 for: 5 >= 5
# vectors can be sized and resized
ok 1653 - v.capacity() == 0 for: 0 == 0
# vectors can be sized and resized
ok 1654 - v.size() == 5 for: 5 == 5
# vectors can be sized and resized
ok 1655 - v.capacity() >= 5 for: 5 >= 5
# vectors can be sized and resized
ok 1656 - v.size() == 5 for: 5 == 5
# vectors can be sized and resized
ok 1657 - v.capacity() >= 10 for: 10 >= 10
# vectors can be sized and resized
ok 1658 - v.size() == 5 for: 5 == 5
# vectors can be sized and resized
ok 1659 - v.capacity() >= 5 for: 5 >= 5
# vectors can be sized and resized
ok 1660 - v.size() == 5 for: 5 == 5
# vectors can be sized and resized
ok 1661 - v.capacity() >= 5 for: 5 >= 5
# xmlentitycheck
ok 1662 -
# xmlentitycheck
ok 1663 -
1..1663

